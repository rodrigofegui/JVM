#include <iostream>
#include "../../lib/Tipos/ByteCode.hpp"
#include "../../lib/Tabelas/TabSimbolos.hpp"
#include "../../lib/Tipos/CPDados.hpp"
#include "../../lib/Uteis/Arquivos.hpp"

std::vector<ByteCode> bytecodes;

/**
 *  Mapeamento bytecode mnem√¥nico <-> manipulador
 */
void iniciar_bytecodes (){
    // 0 (0x00)
    bytecodes.push_back({"nop", 0, FUNC(_nop)});
    // 1 (0x01)
    bytecodes.push_back({"aconst_null", 0, FUNC(_aconst_null)});
    // 2 (0x02)
    bytecodes.push_back({"iconst_m1", 0, FUNC(_iconst_m1)});
    // 3 (0x03)
    bytecodes.push_back({"iconst_0", 0, FUNC(_iconst_0)});
    // 4 (0x04)
    bytecodes.push_back({"iconst_1", 0, FUNC(_iconst_1)});
    // 5 (0x05)
    bytecodes.push_back({"iconst_2", 0, FUNC(_iconst_2)});
    // 6 (0x06)
    bytecodes.push_back({"iconst_3", 0, FUNC(_iconst_3)});
    // 7 (0x07)
    bytecodes.push_back({"iconst_4", 0, FUNC(_iconst_4)});
    // 8 (0x08)
    bytecodes.push_back({"iconst_5", 0, FUNC(_iconst_5)});
    // 9 (0x09)
    bytecodes.push_back({"lconst_0", 0, FUNC(_lconst_0)});
    // 10 (0x0A)
    bytecodes.push_back({"lconst_1", 0, FUNC(_lconst_1)});
    // 11 (0x0B)
    bytecodes.push_back({"fconst_0", 0, FUNC(_fconst_0)});
    // 12 (0x0C)
    bytecodes.push_back({"fconst_1", 0, FUNC(_fconst_1)});
    // 13 (0x0D)
    bytecodes.push_back({"fconst_2", 0, FUNC(_fconst_2)});
    // 14 (0x0E)
    bytecodes.push_back({"dconst_0", 0, FUNC(_dconst_0)});
    // 15 (0x0F)
    bytecodes.push_back({"dconst_1", 0, FUNC(_dconst_1)});
    // 16 (0x10)
    bytecodes.push_back({"bipush", 1, FUNC(_bipush)});
    // 17 (0x11)
    bytecodes.push_back({"sipush", 2, FUNC(_sipush)});
    // 18 (0x12)
    bytecodes.push_back({"ldc", 1, FUNC(_ldc)});
    // 19 (0x13)
    bytecodes.push_back({"ldc_w", 2, FUNC(_ldc_w)});
    // 20 (0x14)
    bytecodes.push_back({"ldc2_w", 2, FUNC(_ldc2_w)});
    // 21 (0x15)
    bytecodes.push_back({"iload", 1, FUNC(_iload)});
    // 22 (0x16)
    bytecodes.push_back({"lload", 1, FUNC(_lload)});
    // 23 (0x17)
    bytecodes.push_back({"fload", 1, FUNC(_fload)});
    // 24 (0x18)
    bytecodes.push_back({"dload", 1, FUNC(_dload)});
    // 25 (0x19)
    bytecodes.push_back({"aload", 1, FUNC(_aload)});
    // 26 (0x1A)
    bytecodes.push_back({"iload_0", 0, FUNC(_iload_0)});
    // 27 (0x1B)
    bytecodes.push_back({"iload_1", 0, FUNC(_iload_1)});
    // 28 (0x1C)
    bytecodes.push_back({"iload_2", 0, FUNC(_iload_2)});
    // 29 (0x1D)
    bytecodes.push_back({"iload_3", 0, FUNC(_iload_3)});
    // 30 (0x1E)
    bytecodes.push_back({"lload_0", 0, FUNC(_lload_0)});
    // 31 (0x1F)
    bytecodes.push_back({"lload_1", 0, FUNC(_lload_1)});
    // 32 (0x20)
    bytecodes.push_back({"lload_2", 0, FUNC(_lload_2)});
    // 33 (0x21)
    bytecodes.push_back({"lload_3", 0, FUNC(_lload_3)});
    // 34 (0x22)
    bytecodes.push_back({"fload_0", 0, FUNC(_fload_0)});
    // 35 (0x23)
    bytecodes.push_back({"fload_1", 0, FUNC(_fload_1)});
    // 36 (0x24)
    bytecodes.push_back({"fload_2", 0, FUNC(_fload_2)});
    // 37 (0x25)
    bytecodes.push_back({"fload_3", 0, FUNC(_fload_3)});
    // 38 (0x26)
    bytecodes.push_back({"dload_0", 0, FUNC(_dload_0)});
    // 39 (0x27)
    bytecodes.push_back({"dload_1", 0, FUNC(_dload_1)});
    // 40 (0x28)
    bytecodes.push_back({"dload_2", 0, FUNC(_dload_2)});
    // 41 (0x29)
    bytecodes.push_back({"dload_3", 0, FUNC(_dload_3)});
    // 42 (0x2A)
    bytecodes.push_back({"aload_0", 0, FUNC(_aload_0)});
    // 43 (0x2B)
    bytecodes.push_back({"aload_1", 0, FUNC(_aload_1)});
    // 44 (0x2C)
    bytecodes.push_back({"aload_2", 0, FUNC(_aload_2)});
    // 45 (0x2D)
    bytecodes.push_back({"aload_3", 0, FUNC(_aload_3)});
    // 46 (0x2E)
    bytecodes.push_back({"iaload", 0, FUNC(_iaload)});
    // 47 (0x2F)
    bytecodes.push_back({"laload", 0, FUNC(_laload)});
    // 48 (0x30)
    bytecodes.push_back({"faload", 0, FUNC(_faload)});
    // 49 (0x31)
    bytecodes.push_back({"daload", 0, FUNC(_daload)});
    // 50 (0x32)
    bytecodes.push_back({"aaload", 0, FUNC(_aaload)});
    // 51 (0x33)
    bytecodes.push_back({"baload", 0, FUNC(_baload)});
    // 52 (0x34)
    bytecodes.push_back({"caload", 0, FUNC(_caload)});
    // 53 (0x35)
    bytecodes.push_back({"saload", 0, FUNC(_saload)});
    // 54 (0x36)
    bytecodes.push_back({"istore", 1, FUNC(_istore)});
    // 55 (0x37)
    bytecodes.push_back({"lstore", 1, FUNC(_lstore)});
    // 56 (0x38)
    bytecodes.push_back({"fstore", 1, FUNC(_fstore)});
    // 57 (0x39)
    bytecodes.push_back({"dstore", 1, FUNC(_dstore)});
    // 58 (0x3A)
    bytecodes.push_back({"astore", 1, FUNC(_astore)});
    // 59 (0x3B)
    bytecodes.push_back({"istore_0", 0, FUNC(_istore_0)});
    // 60 (0x3C)
    bytecodes.push_back({"istore_1", 0, FUNC(_istore_1)});
    // 61 (0x3D)
    bytecodes.push_back({"istore_2", 0, FUNC(_istore_2)});
    // 62 (0x3E)
    bytecodes.push_back({"istore_3", 0, FUNC(_istore_3)});
    // 63 (0x3F)
    bytecodes.push_back({"lstore_0", 0, FUNC(_lstore_0)});
    // 64 (0x40)
    bytecodes.push_back({"lstore_1", 0, FUNC(_lstore_1)});
    // 65 (0x41)
    bytecodes.push_back({"lstore_2", 0, FUNC(_lstore_2)});
    // 66 (0x42)
    bytecodes.push_back({"lstore_3", 0, FUNC(_lstore_3)});
    // 67 (0x43)
    bytecodes.push_back({"fstore_0", 0, FUNC(_fstore_0)});
    // 68 (0x44)
    bytecodes.push_back({"fstore_1", 0, FUNC(_fstore_1)});
    // 69 (0x45)
    bytecodes.push_back({"fstore_2", 0, FUNC(_fstore_2)});
    // 70 (0x46)
    bytecodes.push_back({"fstore_3", 0, FUNC(_fstore_3)});
    // 71 (0x47)
    bytecodes.push_back({"dstore_0", 0, FUNC(_dstore_0)});
    // 72 (0x48)
    bytecodes.push_back({"dstore_1", 0, FUNC(_dstore_1)});
    // 73 (0x49)
    bytecodes.push_back({"dstore_2", 0, FUNC(_dstore_2)});
    // 74 (0x4A)
    bytecodes.push_back({"dstore_3", 0, FUNC(_dstore_3)});
    // 75 (0x4B)
    bytecodes.push_back({"astore_0", 0, FUNC(_astore_0)});
    // 76 (0x4C)
    bytecodes.push_back({"astore_1", 0, FUNC(_astore_1)});
    // 77 (0x4D)
    bytecodes.push_back({"astore_2", 0, FUNC(_astore_2)});
    // 78 (0x4E)
    bytecodes.push_back({"astore_3", 0, FUNC(_astore_3)});
    // 79 (0x4F)
    bytecodes.push_back({"iastore", 0, FUNC(_iastore)});
    // 80 (0x50)
    bytecodes.push_back({"lastore", 0, FUNC(_lastore)});
    // 81 (0x51)
    bytecodes.push_back({"fastore", 0, FUNC(_fastore)});
    // 82 (0x52)
    bytecodes.push_back({"dastore", 0, FUNC(_dastore)});
    // 83 (0x53)
    bytecodes.push_back({"aastore", 0, FUNC(_aastore)});
    // 84 (0x54)
    bytecodes.push_back({"bastore", 0, FUNC(_bastore)});
    // 85 (0x55)
    bytecodes.push_back({"castore", 0, FUNC(_castore)});
    // 86 (0x56)
    bytecodes.push_back({"sastore", 0, FUNC(_sastore)});
    // 87 (0x57)
    bytecodes.push_back({"pop", 0, FUNC(_pop)});
    // 88 (0x58)
    bytecodes.push_back({"pop2", 0, FUNC(_pop2)});
    // 89 (0x59)
    bytecodes.push_back({"dup", 0, FUNC(_dup)});
    // 90 (0x5A)
    bytecodes.push_back({"dup_x1", 0, FUNC(_dup_x1)});
    // 91 (0x5B)
    bytecodes.push_back({"dup_x2", 0, FUNC(_dup_x2)});
    // 92 (0x5C)
    bytecodes.push_back({"dup2", 0, FUNC(_dup2)});
    // 93 (0x5D)
    bytecodes.push_back({"dup2_x1", 0, FUNC(_dup2_x1)});
    // 94 (0x5E)
    bytecodes.push_back({"dup2_x2", 0, FUNC(_dup2_x2)});
    // 95 (0x5F)
    bytecodes.push_back({"swap", 0, FUNC(_swap)});
    // 96 (0x60)
    bytecodes.push_back({"iadd", 0, FUNC(_iadd)});
    // 97 (0x61)
    bytecodes.push_back({"ladd", 0, FUNC(_ladd)});
    // 98 (0x62)
    bytecodes.push_back({"fadd", 0, FUNC(_fadd)});
    // 99 (0x63)
    bytecodes.push_back({"dadd", 0, FUNC(_dadd)});
    // 100 (0x64)
    bytecodes.push_back({"isub", 0, FUNC(_isub)});
    // 101 (0x65)
    bytecodes.push_back({"lsub", 0, FUNC(_lsub)});
    // 102 (0x66)
    bytecodes.push_back({"fsub", 0, FUNC(_fsub)});
    // 103 (0x67)
    bytecodes.push_back({"dsub", 0, FUNC(_dsub)});
    // 104 (0x68)
    bytecodes.push_back({"imul", 0, FUNC(_imul)});
    // 105 (0x69)
    bytecodes.push_back({"lmul", 0, FUNC(_lmul)});
    // 106 (0x6A)
    bytecodes.push_back({"fmul", 0, FUNC(_fmul)});
    // 107 (0x6B)
    bytecodes.push_back({"dmul", 0, FUNC(_dmul)});
    // 108 (0x6C)
    bytecodes.push_back({"idiv", 0, FUNC(_idiv)});
    // 109 (0x6D)
    bytecodes.push_back({"ldiv", 0, FUNC(_ldiv)});
    // 110 (0x6E)
    bytecodes.push_back({"fdiv", 0, FUNC(_fdiv)});
    // 111 (0x6F)
    bytecodes.push_back({"ddiv", 0, FUNC(_ddiv)});
    // 112 (0x70)
    bytecodes.push_back({"irem", 0, FUNC(_irem)});
    // 113 (0x71)
    bytecodes.push_back({"lrem", 0, FUNC(_lrem)});
    // 114 (0x72)
    bytecodes.push_back({"frem", 0, FUNC(_frem)});
    // 115 (0x73)
    bytecodes.push_back({"drem", 0, FUNC(_drem)});
    // 116 (0x74)
    bytecodes.push_back({"ineg", 0, FUNC(_ineg)});
    // 117 (0x75)
    bytecodes.push_back({"lneg", 0, FUNC(_lneg)});
    // 118 (0x76)
    bytecodes.push_back({"fneg", 0, FUNC(_fneg)});
    // 119 (0x77)
    bytecodes.push_back({"dneg", 0, FUNC(_dneg)});
    // 120 (0x78)
    bytecodes.push_back({"ishl", 0, FUNC(_ishl)});
    // 121 (0x79)
    bytecodes.push_back({"lshl", 0, FUNC(_lshl)});
    // 122 (0x7A)
    bytecodes.push_back({"ishr", 0, FUNC(_ishr)});
    // 123 (0x7B)
    bytecodes.push_back({"lshr", 0, FUNC(_lshr)});
    // 124 (0x7C)
    bytecodes.push_back({"iushr", 0, FUNC(_iushr)});
    // 125 (0x7D)
    bytecodes.push_back({"lushr", 0, FUNC(_lushr)});
    // 126 (0x7E)
    bytecodes.push_back({"iand", 0, FUNC(_iand)});
    // 127 (0x7F)
    bytecodes.push_back({"land", 0, FUNC(_land)});
    // 128 (0x80)
    bytecodes.push_back({"ior", 0, FUNC(_ior)});
    // 129 (0x81)
    bytecodes.push_back({"lor", 0, FUNC(_lor)});
    // 130 (0x82)
    bytecodes.push_back({"ixor", 0, FUNC(_ixor)});
    // 131 (0x83)
    bytecodes.push_back({"lxor", 0, FUNC(_lxor)});
    // 132 (0x84)
    bytecodes.push_back({"iinc", 2, FUNC(_iinc)});
    // 133 (0x85)
    bytecodes.push_back({"i2l", 0, FUNC(_i2l)});
    // 134 (0x86)
    bytecodes.push_back({"i2f", 0, FUNC(_i2f)});
    // 135 (0x87)
    bytecodes.push_back({"i2d", 0, FUNC(_i2d)});
    // 136 (0x88)
    bytecodes.push_back({"l2i", 0, FUNC(_l2i)});
    // 137 (0x89)
    bytecodes.push_back({"l2f", 0, FUNC(_l2f)});
    // 138 (0x8A)
    bytecodes.push_back({"l2d", 0, FUNC(_l2d)});
    // 139 (0x8B)
    bytecodes.push_back({"f2i", 0, FUNC(_f2i)});
    // 140 (0x8C)
    bytecodes.push_back({"f2l", 0, FUNC(_f2l)});
    // 141 (0x8D)
    bytecodes.push_back({"f2d", 0, FUNC(_f2d)});
    // 142 (0x8E)
    bytecodes.push_back({"d2i", 0, FUNC(_d2i)});
    // 143 (0x8F)
    bytecodes.push_back({"d2l", 0, FUNC(_d2l)});
    // 144 (0x90)
    bytecodes.push_back({"d2f", 0, FUNC(_d2f)});
    // 145 (0x91)
    bytecodes.push_back({"i2b", 0, FUNC(_i2b)});
    // 146 (0x92)
    bytecodes.push_back({"i2c", 0, FUNC(_i2c)});
    // 147 (0x93)
    bytecodes.push_back({"i2s", 0, FUNC(_i2s)});
    // 148 (0x94)
    bytecodes.push_back({"lcmp", 0, FUNC(_lcmp)});
    // 149 (0x95)
    bytecodes.push_back({"fcmpl", 0, FUNC(_fcmpl)});
    // 150 (0x96)
    bytecodes.push_back({"fcmpg", 0, FUNC(_fcmpg)});
    // 151 (0x97)
    bytecodes.push_back({"dcmpl", 0, FUNC(_dcmpl)});
    // 152 (0x98)
    bytecodes.push_back({"dcmpg", 0, FUNC(_dcmpg)});
    // 153 (0x99)
    bytecodes.push_back({"ifeq", 2, FUNC(_ifeq)});
    // 154 (0x9A)
    bytecodes.push_back({"ifne", 2, FUNC(_ifne)});
    // 155 (0x9B)
    bytecodes.push_back({"iflt", 2, FUNC(_iflt)});
    // 156 (0x9C)
    bytecodes.push_back({"ifge", 2, FUNC(_ifge)});
    // 157 (0x9D)
    bytecodes.push_back({"ifgt", 2, FUNC(_ifgt)});
    // 158 (0x9E)
    bytecodes.push_back({"ifle", 2, FUNC(_ifle)});
    // 159 (0x9F)
    bytecodes.push_back({"if_icmpeq", 2, FUNC(_if_icmpeq)});
    // 160 (0xA0)
    bytecodes.push_back({"if_icmpne", 2, FUNC(_if_icmpne)});
    // 161 (0xA1)
    bytecodes.push_back({"if_icmplt", 2, FUNC(_if_icmplt)});
    // 162 (0xA2)
    bytecodes.push_back({"if_icmpge", 2, FUNC(_if_icmpge)});
    // 163 (0xA3)
    bytecodes.push_back({"if_icmpgt", 2, FUNC(_if_icmpgt)});
    // 164 (0xA4)
    bytecodes.push_back({"if_icmple", 2, FUNC(_if_icmple)});
    // 165 (0xA5)
    bytecodes.push_back({"if_acmpeq", 2, FUNC(_if_acmpeq)});
    // 166 (0xA6)
    bytecodes.push_back({"if_acmpne", 2, FUNC(_if_acmpne)});
    // 167 (0xA7)
    bytecodes.push_back({"goto", 2, FUNC(_goto)});
    // 168 (0xA8)
    bytecodes.push_back({"jsr", 2, FUNC(_jsr)});
    // 169 (0xA9)
    bytecodes.push_back({"ret", 2, FUNC(_ret)});
    // 170 (0xAA)
    bytecodes.push_back({"tableswitch", 34, FUNC(_tableswitch)});
    // 171 (0xAB)
    bytecodes.push_back({"lookupswitch", 26, FUNC(_lookupswitch)});
    // 172 (0xAC)
    bytecodes.push_back({"ireturn", 0, FUNC(_ireturn)});
    // 173 (0xAD)
    bytecodes.push_back({"lreturn", 0, FUNC(_lreturn)});
    // 174 (0xAE)
    bytecodes.push_back({"freturn", 0, FUNC(_freturn)});
    // 175 (0xAF)
    bytecodes.push_back({"dreturn", 0, FUNC(_dreturn)});
    // 176 (0xB0)
    bytecodes.push_back({"areturn", 0, FUNC(_areturn)});
    // 177 (0xB1)
    bytecodes.push_back({"return", 0, FUNC(_return)});
    // 178 (0xB2)
    bytecodes.push_back({"getstatic", 2, FUNC(_getstatic)});
    // 179 (0xB3)
    bytecodes.push_back({"putstatic", 2, FUNC(_putstatic)});
    // 180 (0xB4)
    bytecodes.push_back({"getfield", 2, FUNC(_getfield)});
    // 181 (0xB5)
    bytecodes.push_back({"putfield", 2, FUNC(_putfield)});
    // 182 (0xB6)
    bytecodes.push_back({"invokevirtual", 2, FUNC(_invokevirtual)});
    // 183 (0xB7)
    bytecodes.push_back({"invokespecial", 2, FUNC(_invokespecial)});
    // 184 (0xB8)
    bytecodes.push_back({"invokestatic", 2, FUNC(_invokestatic)});
    // 185 (0xB9)
    bytecodes.push_back({"invokeinterface", 4, FUNC(_invokeinterface)});
    // 186 (0xBA)
    bytecodes.push_back({"invokedynamic", 4, FUNC(_invokedynamic)});
    // 187 (0xBB)
    bytecodes.push_back({"new", 2, FUNC(_new)});
    // 188 (0xBC)
    bytecodes.push_back({"newarray", 1, FUNC(_newarray)});
    // 189 (0xBD)
    bytecodes.push_back({"anewarray", 2, FUNC(_anewarray)});
    // 190 (0xBE)
    bytecodes.push_back({"arraylength", 0, FUNC(_arraylength)});
    // 191 (0xBF)
    bytecodes.push_back({"athrow", 0, FUNC(_athrow)});
    // 192 (0xC0)
    bytecodes.push_back({"checkcast", 2, FUNC(_checkcast)});
    // 193 (0xC1)
    bytecodes.push_back({"instanceof", 2, FUNC(_instanceof)});
    // 194 (0xC2)
    bytecodes.push_back({"monitorenter", 0, FUNC(_monitorenter)});
    // 195 (0xC3)
    bytecodes.push_back({"monitorexit", 0, FUNC(_monitorexit)});
    // 196 (0xC4)
    bytecodes.push_back({"wide", 3, FUNC(_wide)});
    // 197 (0xC5)
    bytecodes.push_back({"multianewarray", 3, FUNC(_multianewarray)});
    // 198 (0xC6)
    bytecodes.push_back({"ifnull", 2, FUNC(_ifnull)});
    // 199 (0xC7)
    bytecodes.push_back({"ifnonnull", 2, FUNC(_ifnonnull)});
    // 200 (0xC8)
    bytecodes.push_back({"goto_w", 4, FUNC(_goto_w)});
    // 201 (0xC9)
    bytecodes.push_back({"jsr_w", 4, FUNC(_jsr_w)});
    // 202 (0xCA)
    bytecodes.push_back({"break_point", 0, FUNC(_break_point)});
    // 203 (0xCB)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 204 (0xCC)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 205 (0xCD)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 206 (0xCE)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 207 (0xCF)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 208 (0xD0)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 209 (0xD1)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 210 (0xD2)
    bytecodes.push_back({"-", 0, FUNC(_undef)});

    // 211 (0xD3)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 212 (0xD4)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 213 (0xD5)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 214 (0xD6)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 215 (0xD7)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 216 (0xD8)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 217 (0xD9)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 218 (0xDA)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 219 (0xDB)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 220 (0xDC)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 221 (0xDD)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 222 (0xDE)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 223 (0xDF)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 224 (0xE0)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 225 (0xE1)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 226 (0xE2)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 227 (0xE3)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 228 (0xE4)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 229 (0xE5)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 230 (0xE6)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 231 (0xE7)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 232 (0xE8)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 233 (0xE9)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 234 (0xEA)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 235 (0xEB)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 236 (0xEC)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 237 (0xED)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 238 (0xEE)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 239 (0xEF)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 240 (0xF0)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 241 (0xF1)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 242 (0xF2)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 243 (0xF3)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 244 (0xF4)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 245 (0xF5)
    bytecodes.push_back({"-", 0, FUNC(_undef)});

    // 246 (0xF6)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 247 (0xF7)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 248 (0xF8)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 249 (0xF9)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 250 (0xFA)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 251 (0xFB)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 252 (0xFC)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 253 (0xFD)
    bytecodes.push_back({"-", 0, FUNC(_undef)});
    // 254 (0xFE)
    bytecodes.push_back({"impdep_1", 0, FUNC(_impdep_1)});
    // 255 (0xFF)
    bytecodes.push_back({"impdep_2", 0, FUNC(_impdep_2)});
}


/**
 *  Classes de manipuladores
 */
void manipulador_undef (Frame *frame){
}

void manipulador_iconst (Frame *frame, int valor){
    Operando *op = new Operando();
    op->tag = TAG_INT;
    op->tipo_int = valor;

    frame->empilhar(op);
    frame->pc++;
}

void manipulador_xstorex_n (Frame *frame, int ind, u1 tag){
    Operando *op = frame->desempilhar();

    if ((op->tag != tag) && (op->tag != TAG_BYTE)){
        std::cout << "N√£o foi poss√≠vel armazenar: o operando √© do tipo errado" << std::endl;
        std::cout << "\t" << get_tag(op->tag) << " n√£o √© " << get_tag(tag) << std::endl;
        return;
    }

    op->atualizar_tipo(tag);

    exibir_se_verboso("\tVar[" + std::to_string((int)ind) + "]: " + op->get());

    frame->var_locais[ind] = op;
    frame->pc++;
}

void manipulador_xstore_n (Frame *frame, u1 ind, u1 tag){
    manipulador_xstorex_n(frame, ind, tag);
}

void manipulador_xstore2_n (Frame *frame, u2 ind, u1 tag){
    manipulador_xstorex_n(frame, ind, tag);
}

void manipulador_xstore (Frame *frame, u1 tag){
    u1 indice = frame->get_prox_byte();

    manipulador_xstore_n (frame, indice, tag);
}

void manipulador_xastore (Frame *frame, u1 tag){
    Operando *valor = frame->desempilhar();
    Operando *indice = frame->desempilhar();
    Operando *lista = frame->desempilhar();

    int ind = (int) indice->tipo_int;

    if (!lista) {
        std::cout << "Exce√ß√£o Ponteiro Nulo" << std::endl;
        return;
    }

    if ((ind < 0) || (ind >= lista->lista_operandos->size())) {
        std::cout << "Exce√ß√£o indice de array fora dos limites" << std::endl;
        return;
    }

    if ((valor->tag != tag) && (valor->tag != TAG_BYTE)){
        std::cout << "N√£o foi poss√≠vel armazenar no array: o operando n√£o √© do tipo correto" << std::endl;
        return;
    }

    // VERIFICAR: QUAL A MELHOR ABORDAGEM?
    // memcpy(&lista->lista_operandos->at(indice->tipo_int), &valor->tipo_float, sizeof(u8));

    valor->atualizar_tipo(tag);
    lista->lista_operandos->at(ind) = valor;
    frame->pc++;
}

void manipulador_xloadx_n (Frame *frame, int ind, u1 tag){
    if (!frame->var_locais[ind]){
        std::cout << "N√£o existe var local" << std::endl;
    }

    exibir_se_verboso("\tA empilhar a Var[" + std::to_string(ind)
        + "]: " + frame->var_locais[ind]->get());

    Operando *op = frame->var_locais[ind];

    if ((op->tag != tag) && (op->tag != TAG_BYTE)){
        std::cout << "N√£o foi poss√≠vel armazenar: o operando √© do tipo errado" << std::endl;
        std::cout << "\t" << get_tag(op->tag) << " n√£o √© " << get_tag(tag) << std::endl;
        return;
    }

    op->atualizar_tipo(tag);

    frame->empilhar(op->duplicar());
    frame->pc++;
}

void manipulador_xload_n (Frame *frame, u1 ind, u1 tag){
    manipulador_xloadx_n (frame, (int) ind, tag);
}

void manipulador_xload2_n (Frame *frame, u2 ind, u1 tag){
    manipulador_xloadx_n (frame, (int) ind, tag);
}

void manipulador_xaload (Frame *frame, u1 tag){
    Operando *indice = frame->desempilhar();
    Operando *lista = frame->desempilhar();

    int ind = (int) indice->tipo_int;

    if (!lista) {
        std::cout << "Exce√ß√£o Ponteiro Nulo" << std::endl;
        return;
    }

    if (lista->tag != TAG_ARR){
        std::cout << "Um " << get_tag(lista->tag) << " n√£o √© um " << get_tag(TAG_ARR) << std::endl;
        return;
    }

    if(ind < 0 || ind >= lista->lista_operandos->size()) {
        std::cout << "Exce√ß√£o indice de array fora dos limites" << std::endl;
        return;
    }

    Operando *a_empilhar = lista->lista_operandos->at(ind);

    if ((a_empilhar->tag != tag) && (a_empilhar->tag != TAG_BYTE)){
        std::cout << "N√£o foi poss√≠vel carregar: o operando √© do tipo errado," << std::endl;
        std::cout << "\tdeveria ser " << get_tag(tag) << std::endl;
        return;
    }

    a_empilhar->atualizar_tipo(tag);    frame->empilhar(a_empilhar);
    frame->pc++;
}

void manipulador_xreturn (Frame *frame, u1 tag){
    if (tag != TAG_VAZ){
        Operando *op = frame->desempilhar();

        if (to_tag(frame->get_tipo_retorno()[0]) != tag){
            std::cout << "O operando deveria ser do tipo " << get_tag(tag);
            std::cout << " mas √© " << get_tag(op->tag) << std::endl;

            return;
        }

        exibir_se_verboso("\tRetornando: " + op->get() + " do tipo " + get_tag(tag));
        frame->retorno = op;

    } else {
        exibir_se_verboso("\tRetorno vazio");
    }

    frame->pode_desempilhar = true;
    frame->pc++;
}

void manipulador_iincx (Frame *frame, int ind, int valor){
    exibir_se_verboso("\tA somar " + std::to_string(valor)
        + " a Var[" + std::to_string(ind) + "]: " + frame->var_locais.at(ind)->get());

    if (frame->var_locais.at(ind)->tag != TAG_INT){
        std::cout << "N√£o √© poss√≠vel somar a um n√£o inteiro, √© ";
        std::cout << get_tag(frame->var_locais.at(ind)->tag) << std::endl;
        return;
    }

    frame->var_locais.at(ind)->tipo_int += valor;

    exibir_se_verboso("\tVar[" + std::to_string(ind) + "]: "
        + frame->var_locais.at(ind)->get());

    frame->pc++;
}

int16_t get_deslocamento (Frame *frame){
    int16_t deslocamento = frame->get_prox_byte();
    deslocamento = (deslocamento << 8) | frame->get_prox_byte();
    deslocamento -= 2;

    return deslocamento;
}


/**
 *  Manipuladores dos bytecodes
 */


// 0 (0x00)
 /**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o nop
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * N√£o executa nenhuma instru√ß√£o.
 */
void manipulador_nop (Frame *frame){
    frame->pc++;
}

// 1 (0x01)
 /**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o aconst_null
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * Coloca a refer√™ncia nula de objeto no topo da pilha de operandos.
 */
void manipulador_aconst_null (Frame *frame){
    Operando *op = new Operando();
    op->tag = TAG_VAZ;

    frame->empilhar(op);
    frame->pc++;
}

// 2 (0x02)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o iconst_m1
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * Coloca a constante tipo inteira -1 no topo da pilha de operandos.
 */
void manipulador_iconst_m1 (Frame *frame){
    manipulador_iconst(frame, -1);
}

// 3 (0x03)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o iconst_0
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * Coloca a constante tipo inteira 0 no topo da pilha de operandos.
 */
void manipulador_iconst_0 (Frame *frame){
    manipulador_iconst(frame, 0);
}

// 4 (0x04)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o iconst_1
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * Coloca a constante tipo inteira 1 no topo da pilha de operandos.
 */
void manipulador_iconst_1 (Frame *frame){
    manipulador_iconst(frame, 1);
}

// 5 (0x05)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o iconst_2
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * Coloca a constante tipo inteira 2 no topo da pilha de operandos.
 */
void manipulador_iconst_2 (Frame *frame){
    manipulador_iconst(frame, 2);
}

// 6 (0x06)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o iconst_3
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * Coloca a constante tipo inteira 3 no topo da pilha de operandos.
 */
void manipulador_iconst_3 (Frame *frame){
    manipulador_iconst(frame, 3);
}

// 7 (0x07)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o iconst_4
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * Coloca a constante tipo inteira 4 no topo da pilha de operandos.
 */
void manipulador_iconst_4 (Frame *frame){
    manipulador_iconst(frame, 4);
}

// 8 (0x08)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o iconst_5
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * Coloca a constante tipo inteira 5 no topo da pilha de operandos.
 */
void manipulador_iconst_5 (Frame *frame){
    manipulador_iconst(frame, 5);
}

// 9 (0x09)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o lconst_0
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * Coloca a constante tipo longo 0 no topo da pilha de operandos.
 */
void manipulador_lconst_0 (Frame *frame){
    Operando *op = new Operando();
    op->tag = TAG_LNG;
    op->tipo_long = 0;

    frame->empilhar(op);
    frame->pc++;
}

// 10 (0x0A)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o lconst_1
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * Coloca a constante tipo longo 1 no topo da pilha de operandos.
 */
void manipulador_lconst_1 (Frame *frame){
    Operando *op = new Operando();
    op->tag = TAG_LNG;
    op->tipo_long = 1;

    frame->empilhar(op);
    frame->pc++;
}

// 11 (0x0B)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o fconst_0
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * Coloca a constante tipo flutuante 0.0 no topo da pilha de operandos.
 */
void manipulador_fconst_0 (Frame *frame){
    Operando *op = new Operando();
    op->tag = TAG_FLT;
    op->tipo_float = 0.0;

    frame->empilhar(op);
    frame->pc++;
}

// 12 (0x0C)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o fconst_1
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * Coloca a constante tipo flutuante 1.0 no topo da pilha de operandos.
 */
void manipulador_fconst_1 (Frame *frame){
    Operando *op = new Operando();
    op->tag = TAG_FLT;
    op->tipo_float = 1.0;

    frame->empilhar(op);
    frame->pc++;
}

// 13 (0x0D)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o fconst_2
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * Coloca a constante tipo flutuante 2.0 no topo da pilha de operandos.
 */
void manipulador_fconst_2 (Frame *frame){
    Operando *op = new Operando();
    op->tag = TAG_FLT;
    op->tipo_float = 2.0;

    frame->empilhar(op);
    frame->pc++;
}

// 14 (0x0E)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o dconst_0
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * Coloca a constante tipo double 0.0 no topo da pilha de operandos.
 */
void manipulador_dconst_0 (Frame *frame){
    Operando *op = new Operando();
    op->tag = TAG_DBL;
    op->tipo_double = 0.0;

    frame->empilhar(op);
    frame->pc++;
}

// 15 (0x0F)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o dconst_1
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * Coloca a constante tipo double 1.0 no topo da pilha de operandos.
 */
void manipulador_dconst_1 (Frame *frame){
    Operando *op = new Operando();
    op->tag = TAG_DBL;
    op->tipo_double = 1.0;

    frame->empilhar(op);
    frame->pc++;
}

// 16 (0x10)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o bipush
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * Extende o sinal do byte imediato para um valor do tipo inteiro.
 */
void manipulador_bipush (Frame *frame){
    u1 byte = frame->get_prox_byte();

    Operando *op = new Operando();
    op->tag = TAG_BYTE;
    op->tipo_byte = byte;

    frame->empilhar(op);
    frame->pc++;
}

// 17 (0x11)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o sipush
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * Os valores dos bytes imediatos byte1 e byte2 s√£o colocados em um intermedi√°rio de tipo short, onde o valor do short √© (byte1 << 8) | byte2. O tipo do valor do intermedi√°rio √©, ent√£o, extendido para um valor do tipo inteiro. Esse valor √© colocado no topo da pilha de operandos.
 */
void manipulador_sipush (Frame *frame){
    u1 byte1 = frame->get_prox_byte();
    u1 byte2 = frame->get_prox_byte();

    Operando *op = new Operando();
    op->tag = TAG_BYTE;
    op->tipo_byte = (byte1 << 8) | byte2;

    frame->empilhar(op);
    frame->pc++;
}

// 18 (0x12)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o ldc
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O √≠ndice √© um byte sem sinal que precisa ser um √≠ndice valido para a pool de constantes em tempo de execu√ß√£o da classe atual. O acesso √† pool de constantes em tempo de execu√ß√£o no √≠ndice deve ser uma constante em tempo de execu√ß√£o do tipo inteiro, flutuante, refer√™ncia para um literal de uma string ou refer√™ncia simb√≥lica para uma classe, tipo de m√©todo ou handle de m√©todo.
 * Se o acesso em tempo de execu√ß√£o √† pool de constante for do tipo inteiro ou flutuante, o valor num√©rico dessa constante em tempo de execu√ß√£o √© colocado no topo da pilha de operandos como inteiro ou flutuante, respectivamente.
 * Caso contr√°rio, se a pool de constante em tempo de execu√ß√£o √© uma refer√™ncia para uma inst√¢ncia da classe String, representando um literal de uma string, ent√£o uma refer√™ncia para essa inst√¢ncia, op, √© colocado no topo da pilha de operandos.
 * Caso contr√°rio, se a pool de constante em tempo de execu√ß√£o √© uma refer√™ncia para uma classe, ent√£o a classe nomeada √© resolvida, e uma refer√™ncia para o Class object representando essa classe, op, √© colocado no topo da pilha de operandos.
 * Caso contr√°rio, a pool de constante em tempo de execu√ß√£o deve ser uma refer√™ncia simb√≥lica para um tipo ou handle de m√©todo. O tipo de m√©todo ou handle, √© resolvido, e uma refer√™ncia para a inst√¢ncia resultante de java.lang.invoke.MethodType ou java.lang.invoke.MethodHandle, po, √© colocado no topo da pilha de operandos.
 */
void manipulador_ldc (Frame *frame){
    u1 indice = frame->get_prox_byte();

    InterCPDado *c_dados =  frame->buscar_simbolo(indice);

    if (!c_dados){
        std::cout << "N√£o existe dados no √≠ndice: " << indice << std::endl;
        return;
    }

    if ((c_dados->tag != TAG_STR) && (c_dados->tag != TAG_FLT) && (c_dados->tag != TAG_INT)){
        std::cout << "N√£o foi poss√≠vel armazenar: s√≠mbolo n√£o √© do tipo correto" << std::endl;
        std::cout << "\t" << get_tag(c_dados->tag) << " n√£o √© " << get_tag(TAG_STR) << ", ";
        std::cout << get_tag(TAG_FLT) << " ou " << get_tag(TAG_INT) << std::endl;
        return;
    }

    Operando *op = new Operando();
    op->tag = c_dados->tag;

    switch (op->tag) {
        case TAG_STR:
            op->tipo_string = (dynamic_cast<InfoString*>(c_dados))->get();
            break;
        case TAG_FLT:
            op->tipo_float = std::stof((dynamic_cast<InfoFloat*>(c_dados))->get());
            break;
        case TAG_INT:
            op->tipo_int = std::stoi((dynamic_cast<InfoInteiro*>(c_dados))->get());
            break;
    }

    frame->empilhar(op);
    frame->pc++;
}

// 19 (0x13)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o ldc_w
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * Os bytes sem sinal, byte1 e byte2 s√£o montados em um √≠ndice sem sinal de 16-bits em uma pool de constante em tempo de execu√ß√£o da classe atual, onde o valor do √≠ndice √© calculado como (byte1 << 8) | byte2. O acesso √† pool de constantes em tempo de execu√ß√£o no √≠ndice deve ser v√°lido e deve ser uma constante em tempo de execu√ß√£o do tipo inteiro, flutuante, refer√™ncia para um literal de string ou uma refer√™ncia simb√≥lica para uma classe, tipo de m√©todo ou handle de m√©todo.
 * Se o acesso em tempo de execu√ß√£o √† pool de constante for do tipo inteiro ou flutuante, o valor num√©rico dessa constante em tempo de execu√ß√£o √© colocado no topo da pilha de operandos como inteiro ou flutuante, respectivamente.
 * Caso contr√°rio, se a pool de constante em tempo de execu√ß√£o √© uma refer√™ncia para uma inst√¢ncia da classe String, representando um literal de uma string, ent√£o uma refer√™ncia para essa inst√¢ncia, op, √© colocado no topo da pilha de operandos.
 * Caso contr√°rio, se a pool de constante em tempo de execu√ß√£o √© uma refer√™ncia para uma classe, ent√£o a classe nomeada √© resolvida, e uma refer√™ncia para o Class object representando essa classe, op, √© colocado no topo da pilha de operandos.
 * Caso contr√°rio, a pool de constante em tempo de execu√ß√£o deve ser uma refer√™ncia simb√≥lica para um tipo ou handle de m√©todo. O tipo de m√©todo ou handle, √© resolvido, e uma refer√™ncia para a inst√¢ncia resultante de java.lang.invoke.MethodType ou java.lang.invoke.MethodHandle, po, √© colocado no topo da pilha de operandos.
 */
void manipulador_ldc_w (Frame *frame){
    u1 byte_1 = frame->get_prox_byte();
    u1 byte_2 = frame->get_prox_byte();
    u2 indice = (byte_1 << 8) | byte_2;

    InterCPDado *c_dados =  frame->buscar_simbolo(indice);

    if (!c_dados){
        std::cout << "N√£o existe dados no √≠ndice: " << indice << std::endl;
        return;
    }

    if ((c_dados->tag != TAG_STR) && (c_dados->tag != TAG_FLT) && (c_dados->tag != TAG_INT)){
        std::cout << "N√£o foi poss√≠vel armazenar: s√≠mbolo n√£o √© do tipo correto" << std::endl;
        std::cout << "\t" << get_tag(c_dados->tag) << " n√£o √© " << get_tag(TAG_STR) << ", ";
        std::cout << get_tag(TAG_FLT) << " ou " << get_tag(TAG_INT) << std::endl;
        return;
    }

    Operando *op = new Operando();
    op->tag = c_dados->tag;

    switch (op->tag) {
        case TAG_STR:
            op->tipo_string = (dynamic_cast<InfoString*>(c_dados))->get();
            break;
        case TAG_FLT:
            op->tipo_float = std::stof((dynamic_cast<InfoFloat*>(c_dados))->get());
            break;
        case TAG_INT:
            op->tipo_int = std::stoi((dynamic_cast<InfoInteiro*>(c_dados))->get());
            break;
    }

    frame->empilhar(op);
    frame->pc++;
}

// 20 (0x14)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o ldc2_w
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * Os bytes sem sinal, byte1 e byte2 s√£o montados em um √≠ndice sem sinal de 16-bits em uma pool de constante em tempo de execu√ß√£o da classe atual, onde o valor do √≠ndice √© calculado como (byte1 << 8) | byte2. O acesso √† pool de constantes em tempo de execu√ß√£o no √≠ndice deve ser v√°lido e deve ser uma constante em tempo de execu√ß√£o do tipo longo ou double, o valor num√©rico dessa constante em tempo de execu√ß√£o √© colocado no topo da pilha de operandos como flutuante ou double, respectivamente.
 */
void manipulador_ldc2_w (Frame *frame){
    u1 byte_1 = frame->get_prox_byte();
    u1 byte_2 = frame->get_prox_byte();
    u2 indice = (byte_1 << 8) | byte_2;

    InterCPDado *c_dados = frame->buscar_simbolo(indice);

    if (!c_dados){
        std::cout << "N√£o existe dados no √≠ndice: " << indice << std::endl;
        return;
    }

    if ((c_dados->tag != TAG_DBL) && (c_dados->tag != TAG_LNG)){
        std::cout << "N√£o foi poss√≠vel armazenar: s√≠mbolo n√£o √© do tipo correto" << std::endl;
        std::cout << "\t" << get_tag(c_dados->tag) << " n√£o √© " << get_tag(TAG_DBL);
        std::cout << " ou " << get_tag(TAG_LNG) << std::endl;
        return;
    }

    Operando *op = new Operando();
    op->tag = c_dados->tag;

    switch(op->tag) {
        case TAG_DBL:
            op->tipo_double = std::stod((dynamic_cast<InfoDouble*>(c_dados))->get());
            break;

        default:
            op->tipo_long = std::stol((dynamic_cast<InfoLong*>(c_dados))->get());
    }

    frame->empilhar(op);
    frame->pc++;
}

// 21 (0x15)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o iload
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O √≠ndice (passsado para manipulador_xload_n como o pr√≥ximo byte do frame) √© um byte sem sinal que deve ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. A vari√°vel local na posi√ß√£o do √≠ndice deve conter um inteiro. O valor da vari√°vel local na posi√ß√£o do √≠ndice √© colocado no topo da pilha de operandos.
 */
void manipulador_iload (Frame *frame){
    manipulador_xload_n(frame, frame->get_prox_byte(), TAG_INT);
}

// 22 (0x16)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o lload
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O √≠ndice (passsado para manipulador_xload_n como o pr√≥ximo byte do frame) √© um byte sem sinal. Tanto o √≠ndice quanto o √≠ndice+1 devem ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. A vari√°vel local na posi√ß√£o do √≠ndice deve conter um tipo longo. O valor da vari√°vel local na posi√ß√£o do √≠ndice √© colocado no topo da pilha de operandos.
 */
void manipulador_lload (Frame *frame){
    manipulador_xload_n(frame, frame->get_prox_byte(), TAG_LNG);
}

// 23 (0x17)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o fload
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O √≠ndice (passsado para manipulador_xload_n como o pr√≥ximo byte do frame) √© um byte sem sinal que deve ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. A vari√°vel local na posi√ß√£o do √≠ndice deve conter um tipo flutuante. O valor da vari√°vel local na posi√ß√£o do √≠ndice √© colocado no topo da pilha de operandos.
 */
void manipulador_fload (Frame *frame){
    manipulador_xload_n(frame, frame->get_prox_byte(), TAG_FLT);
}

// 24 (0x18)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o dload
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * Tanto o √≠ndice (passsado para manipulador_xload_n como o pr√≥ximo byte do frame) quanto o √≠ndice+1 devem ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. A vari√°vel local na posi√ß√£o do √≠ndice deve conter um tipo double. O valor da vari√°vel local na posi√ß√£o do √≠ndice √© colocado no topo da pilha de operandos.
 */
void manipulador_dload (Frame *frame){
    manipulador_xload_n(frame, frame->get_prox_byte(), TAG_DBL);
}

// 25 (0x19)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o aload
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O √≠ndice (passsado para manipulador_xload_n como o pr√≥ximo byte do frame) √© um byte sem sinal que deve ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. A vari√°vel local na posi√ß√£o do √≠ndice deve conter uma refer√™ncia. O objectref na posi√ß√£o do √≠ndice √© colocado no topo da pilha de operandos.
 */
void manipulador_aload (Frame *frame){
    manipulador_xload_n(frame, frame->get_prox_byte(), TAG_ARR);
}

// 26 (0x1A)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o iload_0
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O √≠ndice (0) deve ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. A vari√°vel local na posi√ß√£o do √≠ndice deve conter um inteiro. O valor da vari√°vel local na posi√ß√£o do √≠ndice √© colocado no topo da pilha de operandos.
 */
void manipulador_iload_0 (Frame *frame){
    manipulador_xload_n(frame, 0, TAG_INT);
}

// 27 (0x1B)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o iload_1
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O √≠ndice (1) deve ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. A vari√°vel local na posi√ß√£o do √≠ndice deve conter um inteiro. O valor da vari√°vel local na posi√ß√£o do √≠ndice √© colocado no topo da pilha de operandos.
 */
void manipulador_iload_1 (Frame *frame){
    manipulador_xload_n(frame, 1, TAG_INT);
}

// 28 (0x1C)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o iload_2
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O √≠ndice (2) deve ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. A vari√°vel local na posi√ß√£o do √≠ndice deve conter um inteiro. O valor da vari√°vel local na posi√ß√£o do √≠ndice √© colocado no topo da pilha de operandos.
 */
void manipulador_iload_2 (Frame *frame){
    manipulador_xload_n(frame, 2, TAG_INT);
}

// 29 (0x1D)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o iload_3
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O √≠ndice (3) deve ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. A vari√°vel local na posi√ß√£o do √≠ndice deve conter um inteiro. O valor da vari√°vel local na posi√ß√£o do √≠ndice √© colocado no topo da pilha de operandos.
 */
void manipulador_iload_3 (Frame *frame){
    manipulador_xload_n(frame, 3, TAG_INT);
}

// 30 (0x1E)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o lload_0
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * Tanto o √≠ndice (0) quanto o √≠ndice+1 (1) devem ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. A vari√°vel local na posi√ß√£o do √≠ndice deve conter um tipo longo. O valor da vari√°vel local na posi√ß√£o do √≠ndice √© colocado no topo da pilha de operandos.
 */
void manipulador_lload_0 (Frame *frame){
    manipulador_xload_n(frame, 0, TAG_LNG);
}

// 31 (0x1F)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o lload_1
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * Tanto o √≠ndice (1) quanto o √≠ndice+1 (2) devem ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. A vari√°vel local na posi√ß√£o do √≠ndice deve conter um tipo longo. O valor da vari√°vel local na posi√ß√£o do √≠ndice √© colocado no topo da pilha de operandos.
 */
void manipulador_lload_1 (Frame *frame){
    manipulador_xload_n(frame, 1, TAG_LNG);
}

// 32 (0x20)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o lload_2
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * Tanto o √≠ndice (2) quanto o √≠ndice+1 (3) devem ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. A vari√°vel local na posi√ß√£o do √≠ndice deve conter um tipo longo. O valor da vari√°vel local na posi√ß√£o do √≠ndice √© colocado no topo da pilha de operandos.
 */
void manipulador_lload_2 (Frame *frame){
    manipulador_xload_n(frame, 2, TAG_LNG);
}

// 33 (0x21)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o lload_3
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * Tanto o √≠ndice (3) quanto o √≠ndice+1 (4) devem ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. A vari√°vel local na posi√ß√£o do √≠ndice deve conter um tipo longo. O valor da vari√°vel local na posi√ß√£o do √≠ndice √© colocado no topo da pilha de operandos.
 */
void manipulador_lload_3 (Frame *frame){
    manipulador_xload_n(frame, 3, TAG_LNG);
}

// 34 (0x22)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o fload_0
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice (0) deve ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. A vari√°vel local na posi√ß√£o do √≠ndice deve conter um tipo flutuante. O valor da vari√°vel local na posi√ß√£o do √≠ndice √© colocado no topo da pilha de operandos.
 */
void manipulador_fload_0 (Frame *frame){
    manipulador_xload_n(frame, 0, TAG_FLT);
}

// 35 (0x23)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o fload_1
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice (1) deve ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. A vari√°vel local na posi√ß√£o do √≠ndice deve conter um tipo flutuante. O valor da vari√°vel local na posi√ß√£o do √≠ndice √© colocado no topo da pilha de operandos.
 */
void manipulador_fload_1 (Frame *frame){
    manipulador_xload_n(frame, 1, TAG_FLT);
}

// 36 (0x24)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o fload_2
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice (2) deve ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. A vari√°vel local na posi√ß√£o do √≠ndice deve conter um tipo flutuante. O valor da vari√°vel local na posi√ß√£o do √≠ndice √© colocado no topo da pilha de operandos.
 */
void manipulador_fload_2 (Frame *frame){
    manipulador_xload_n(frame, 2, TAG_FLT);
}

// 37 (0x25)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o fload_3
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice (3) deve ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. A vari√°vel local na posi√ß√£o do √≠ndice deve conter um tipo flutuante. O valor da vari√°vel local na posi√ß√£o do √≠ndice √© colocado no topo da pilha de operandos.
 */
void manipulador_fload_3 (Frame *frame){
    manipulador_xload_n(frame, 3, TAG_FLT);
}

// 38 (0x26)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o dload_0
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * Tanto o √≠ndice (0) quanto o √≠ndice+1 (1) devem ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. A vari√°vel local na posi√ß√£o do √≠ndice deve conter um tipo double. O valor da vari√°vel local na posi√ß√£o do √≠ndice √© colocado no topo da pilha de operandos.
 */
void manipulador_dload_0 (Frame *frame){
    manipulador_xload_n(frame, 0, TAG_DBL);
}

// 39 (0x27)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o dload_1
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * Tanto o √≠ndice (1) quanto o √≠ndice+1 (2) devem ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. A vari√°vel local na posi√ß√£o do √≠ndice deve conter um tipo double. O valor da vari√°vel local na posi√ß√£o do √≠ndice √© colocado no topo da pilha de operandos.
 */
void manipulador_dload_1 (Frame *frame){
    manipulador_xload_n(frame, 1, TAG_DBL);
}

// 40 (0x28)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o dload_2
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * Tanto o √≠ndice (2) quanto o √≠ndice+1 (3) devem ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. A vari√°vel local na posi√ß√£o do √≠ndice deve conter um tipo double. O valor da vari√°vel local na posi√ß√£o do √≠ndice √© colocado no topo da pilha de operandos.
 */
void manipulador_dload_2 (Frame *frame){
    manipulador_xload_n(frame, 2, TAG_DBL);
}

// 41 (0x29)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o dload_3
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * Tanto o √≠ndice (3) quanto o √≠ndice+1 (4) devem ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. A vari√°vel local na posi√ß√£o do √≠ndice deve conter um tipo double. O valor da vari√°vel local na posi√ß√£o do √≠ndice √© colocado no topo da pilha de operandos.
 */
void manipulador_dload_3 (Frame *frame){
    manipulador_xload_n(frame, 3, TAG_DBL);
}

// 42 (0x2A)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o aload_0
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice (0) deve ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. A vari√°vel local na posi√ß√£o do √≠ndice deve conter uma refer√™mcia. O objectref na vari√°vel local na posi√ß√£o do √≠ndice √© colocado no topo da pilha de operandos.
 */
void manipulador_aload_0 (Frame *frame){
    manipulador_xload_n(frame, 0, TAG_ARR);
}

// 43 (0x2B)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o aload_1
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice (1) deve ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. A vari√°vel local na posi√ß√£o do √≠ndice deve conter uma refer√™mcia. O objectref na vari√°vel local na posi√ß√£o do √≠ndice √© colocado no topo da pilha de operandos.
 */
void manipulador_aload_1 (Frame *frame){
    manipulador_xload_n(frame, 1, TAG_ARR);
}

// 44 (0x2C)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o aload_2
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice (2) deve ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. A vari√°vel local na posi√ß√£o do √≠ndice deve conter uma refer√™mcia. O objectref na vari√°vel local na posi√ß√£o do √≠ndice √© colocado no topo da pilha de operandos.
 */
void manipulador_aload_2 (Frame *frame){
    manipulador_xload_n(frame, 2, TAG_ARR);
}

// 45 (0x2D)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o aload_3
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice (3) deve ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. A vari√°vel local na posi√ß√£o do √≠ndice deve conter uma refer√™mcia. O objectref na vari√°vel local na posi√ß√£o do √≠ndice √© colocado no topo da pilha de operandos.
 */
void manipulador_aload_3 (Frame *frame){
    manipulador_xload_n(frame, 3, TAG_ARR);
}

// 46 (0x2E)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o iaload
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O arrayref deve ser do tipo refer√™ncia e precisa referenciar um vetor cujos componentes s√£o do tipo inteiro. O √≠ndice precisa ser do tipo inteiro. Tanto arrayref quanto o √≠ndice s√£o removidos do topo da pilha de operandos. O inteiro na posi√ß√£o do √≠ndice √© encontrado e colocado no topo da pilha de operandos.
 */
void manipulador_iaload (Frame *frame){
    manipulador_xaload(frame, TAG_INT);
}

// 47 (0x2F)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o laload
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O arrayref deve ser do tipo refer√™ncia e precisa referenciar um vetor cujos componentes s√£o do tipo long. O √≠ndice precisa ser do tipo inteiro. Tanto arrayref quanto o √≠ndice s√£o removidos do topo da pilha de operandos. O long na posi√ß√£o do √≠ndice √© encontrado e colocado no topo da pilha de operandos.
 */
void manipulador_laload (Frame *frame){
    manipulador_xaload(frame, TAG_LNG);
}

// 48 (0x30)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o faload
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O arrayref deve ser do tipo refer√™ncia e precisa referenciar um vetor cujos componentes s√£o do tipo flutuante. O √≠ndice precisa ser do tipo inteiro. Tanto arrayref quanto o √≠ndice s√£o removidos do topo da pilha de operandos. O flutuante na posi√ß√£o do √≠ndice √© encontrado e colocado no topo da pilha de operandos.
 */
void manipulador_faload (Frame *frame){
    manipulador_xaload(frame, TAG_FLT);
}

// 49 (0x31)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o daload
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O arrayref deve ser do tipo refer√™ncia e precisa referenciar um vetor cujos componentes s√£o do tipo double. O √≠ndice precisa ser do tipo inteiro. Tanto arrayref quanto o √≠ndice s√£o removidos do topo da pilha de operandos. O double na posi√ß√£o do √≠ndice √© encontrado e colocado no topo da pilha de operandos.
 */
void manipulador_daload (Frame *frame){
    manipulador_xaload(frame, TAG_DBL);
}

// 50 (0x32)
/**
 * @brief 
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O arrayref deve ser do tipo refer√™ncia e precisa referenciar um vetor cujos componentes s√£o do tipo refer√™ncia. O √≠ndice precisa ser do tipo inteiro. Tanto arrayref quanto o √≠ndice s√£o removidos do topo da pilha de operandos. A refer√™ncia na posi√ß√£o do √≠ndice √© encontrada e colocado no topo da pilha de operandos.
 */
void manipulador_aaload (Frame *frame){
    manipulador_xaload(frame, TAG_REF);
}

// 51 (0x33)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o baload
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O arrayref deve ser do tipo refer√™ncia e precisa referenciar um vetor cujos componentes s√£o do tipo booleano. O √≠ndice precisa ser do tipo inteiro. Tanto arrayref quanto o √≠ndice s√£o removidos do topo da pilha de operandos. O byte na posi√ß√£o do √≠ndice √© encontrado, extendido para tipo inteiro e colocado no topo da pilha de operandos.
 */
void manipulador_baload (Frame *frame){
    manipulador_xaload(frame, TAG_INT);
}

// 52 (0x34)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o caload
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O arrayref deve ser do tipo refer√™ncia e precisa referenciar um vetor cujos componentes s√£o do tipo char. O √≠ndice precisa ser do tipo inteiro. Tanto arrayref quanto o √≠ndice s√£o removidos do topo da pilha de operandos. O byte na posi√ß√£o do √≠ndice √© encontrado, extendido com zero para tipo inteiro e colocado no topo da pilha de operandos.
 */
void manipulador_caload (Frame *frame){
    manipulador_xaload(frame, TAG_CHR);
}

// 53 (0x35)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o saload
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O arrayref deve ser do tipo refer√™ncia e precisa referenciar um vetor cujos componentes s√£o do tipo short. O √≠ndice precisa ser do tipo inteiro. Tanto arrayref quanto o √≠ndice s√£o removidos do topo da pilha de operandos. O byte na posi√ß√£o do √≠ndice √© encontrado, extendido com sinal para tipo inteiro e colocado no topo da pilha de operandos.
 */
void manipulador_saload (Frame *frame){
    manipulador_xaload(frame, TAG_INT);
}

// 54 (0x36)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o istore
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice √© um byte sem sinal que deve ser um √≠ndice para o vetor de vari√°veis locais do frame atual. O elemento no topo da pilha de operandos deve ser do tipo inteiro. Esse elemento √© retirado do topo da pilha, e o valor da vari√°vel no √≠ndice recebe o valor do elemento.
 */
void manipulador_istore (Frame *frame){
    manipulador_xstore(frame, TAG_INT);
}

// 55 (0x37)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o lstore
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice √© um byte sem sinal. Tanto o √≠ndice quanto o √≠ndice+1 devem ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. O elemento no topo da pilha de operandos deve ser do tipo long. Esse elemento √© retirado do topo da pilha, e o valor da vari√°vel no √≠ndice e no √≠ndice+1 recebem o valor do elemento.
 */
void manipulador_lstore (Frame *frame){
    manipulador_xstore(frame, TAG_LNG);
}

// 56 (0x38)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o fstore
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice √© um byte sem sinal que deve ser um √≠ndice para o vetor de vari√°veis locais do frame atual. O elemento no topo da pilha de operandos deve ser do tipo flutuante. Esse elemento √© retirado do topo da pilha e passa por uma convers√£o resultando em um valor'. O valor da vari√°vel no √≠ndice recebe valor'.
 */
void manipulador_fstore (Frame *frame){
    manipulador_xstore(frame, TAG_FLT);
}

// 57 (0x39)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o dstore
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice √© um byte sem sinal. Tanto o √≠ndice quanto o √≠ndice+1 devem ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. O elemento no topo da pilha de operandos deve ser do tipo double. Esse elemento √© retirado do topo da pilha e passa por uma convers√£o resultando em um valor'. O valor da vari√°vel no √≠ndice e no √≠ndice+1 recebem valor'.
 */
void manipulador_dstore (Frame *frame){
    manipulador_xstore(frame, TAG_DBL);
}

// 58 (0x3A)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o astore
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice √© um byte sem sinal que deve ser um √≠ndice para o vetor de vari√°veis locais do frame atual. O elemento no topo da pilha de operandos deve ser do tipo returnAddress ou refer√™ncia. Esse elemento √© retirado do topo da pilha, e o valor da vari√°vel no √≠ndice recebe objectref.
 */
void manipulador_astore (Frame *frame){
    manipulador_xstore(frame, TAG_ARR);
}

// 59 (0x3B)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o istore_0
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice (0) √© um byte sem sinal que deve ser um √≠ndice para o vetor de vari√°veis locais do frame atual. O elemento no topo da pilha de operandos deve ser do tipo inteiro. Esse elemento √© retirado do topo da pilha, e o valor da vari√°vel no √≠ndice recebe o valor do elemento.
 */
void manipulador_istore_0 (Frame *frame){
    manipulador_xstore_n(frame, 0, TAG_INT);
}

// 60 (0x3C)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o istore_1
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice (1) √© um byte sem sinal que deve ser um √≠ndice para o vetor de vari√°veis locais do frame atual. O elemento no topo da pilha de operandos deve ser do tipo inteiro. Esse elemento √© retirado do topo da pilha, e o valor da vari√°vel no √≠ndice recebe o valor do elemento.
 */
void manipulador_istore_1 (Frame *frame){
    manipulador_xstore_n(frame, 1, TAG_INT);
}

// 61 (0x3D)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o istore_2
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice (2) √© um byte sem sinal que deve ser um √≠ndice para o vetor de vari√°veis locais do frame atual. O elemento no topo da pilha de operandos deve ser do tipo inteiro. Esse elemento √© retirado do topo da pilha, e o valor da vari√°vel no √≠ndice recebe o valor do elemento.
 */
void manipulador_istore_2 (Frame *frame){
    manipulador_xstore_n(frame, 2, TAG_INT);
}

// 62 (0x3E)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o istore_3
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice (3) √© um byte sem sinal que deve ser um √≠ndice para o vetor de vari√°veis locais do frame atual. O elemento no topo da pilha de operandos deve ser do tipo inteiro. Esse elemento √© retirado do topo da pilha, e o valor da vari√°vel no √≠ndice recebe o valor do elemento.
 */
void manipulador_istore_3 (Frame *frame){
    manipulador_xstore_n(frame, 3, TAG_INT);
}

// 63 (0x3F)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o lstore_0
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice (0) √© um byte sem sinal. Tanto o √≠ndice (0) quanto o √≠ndice+1 (1) devem ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. O elemento no topo da pilha de operandos deve ser do tipo long. Esse elemento √© retirado do topo da pilha, e o valor da vari√°vel no √≠ndice e no √≠ndice+1 recebem o valor do elemento.
 */
void manipulador_lstore_0 (Frame *frame){
    manipulador_xstore_n(frame, 0, TAG_LNG);
}

// 64 (0x40)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o lstore_1
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice (1) √© um byte sem sinal. Tanto o √≠ndice (1) quanto o √≠ndice+1 (2) devem ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. O elemento no topo da pilha de operandos deve ser do tipo long. Esse elemento √© retirado do topo da pilha, e o valor da vari√°vel no √≠ndice e no √≠ndice+1 recebem o valor do elemento.
 */
void manipulador_lstore_1 (Frame *frame){
    manipulador_xstore_n(frame, 1, TAG_LNG);
}

// 65 (0x41)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o lstore_2
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice (2) √© um byte sem sinal. Tanto o √≠ndice (2) quanto o √≠ndice+1 (3) devem ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. O elemento no topo da pilha de operandos deve ser do tipo long. Esse elemento √© retirado do topo da pilha, e o valor da vari√°vel no √≠ndice e no √≠ndice+1 recebem o valor do elemento.
 */
void manipulador_lstore_2 (Frame *frame){
    manipulador_xstore_n(frame, 2, TAG_LNG);
}

// 66 (0x42)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o lstore_3
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice (3) √© um byte sem sinal. Tanto o √≠ndice (3) quanto o √≠ndice+1 (4) devem ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. O elemento no topo da pilha de operandos deve ser do tipo long. Esse elemento √© retirado do topo da pilha, e o valor da vari√°vel no √≠ndice e no √≠ndice+1 recebem o valor do elemento.
 */
void manipulador_lstore_3 (Frame *frame){
    manipulador_xstore_n(frame, 3, TAG_LNG);
}

// 67 (0x43)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o fstore_0
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice (0) √© um byte sem sinal que deve ser um √≠ndice para o vetor de vari√°veis locais do frame atual. O elemento no topo da pilha de operandos deve ser do tipo flutuante. Esse elemento √© retirado do topo da pilha e passa por uma convers√£o resultando em um valor'. O valor da vari√°vel no √≠ndice recebe valor'.
 */
void manipulador_fstore_0 (Frame *frame){
    manipulador_xstore_n(frame, 0, TAG_FLT);
}

// 68 (0x44)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o fstore_1
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice (1) √© um byte sem sinal que deve ser um √≠ndice para o vetor de vari√°veis locais do frame atual. O elemento no topo da pilha de operandos deve ser do tipo flutuante. Esse elemento √© retirado do topo da pilha e passa por uma convers√£o resultando em um valor'. O valor da vari√°vel no √≠ndice recebe valor'.
 */
void manipulador_fstore_1 (Frame *frame){
    manipulador_xstore_n(frame, 1, TAG_FLT);
}

// 69 (0x45)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o fstore_2
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice (2) √© um byte sem sinal que deve ser um √≠ndice para o vetor de vari√°veis locais do frame atual. O elemento no topo da pilha de operandos deve ser do tipo flutuante. Esse elemento √© retirado do topo da pilha e passa por uma convers√£o resultando em um valor'. O valor da vari√°vel no √≠ndice recebe valor'.
 */
void manipulador_fstore_2 (Frame *frame){
    manipulador_xstore_n(frame, 2, TAG_FLT);
}

// 70 (0x46)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o fstore_3
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice (3) √© um byte sem sinal que deve ser um √≠ndice para o vetor de vari√°veis locais do frame atual. O elemento no topo da pilha de operandos deve ser do tipo flutuante. Esse elemento √© retirado do topo da pilha e passa por uma convers√£o resultando em um valor'. O valor da vari√°vel no √≠ndice recebe valor'.
 */
void manipulador_fstore_3 (Frame *frame){
    manipulador_xstore_n(frame, 3, TAG_FLT);
}

// 71 (0x47)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o dstore_0
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice (0) √© um byte sem sinal. Tanto o √≠ndice (0) quanto o √≠ndice+1 (1) devem ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. O elemento no topo da pilha de operandos deve ser do tipo double. Esse elemento √© retirado do topo da pilha e passa por uma convers√£o resultando em um valor'. O valor da vari√°vel no √≠ndice e no √≠ndice+1 recebem valor'.
 */
void manipulador_dstore_0 (Frame *frame){
    manipulador_xstore_n(frame, 0, TAG_DBL);
}

// 72 (0x48)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o dstore_1
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice (1) √© um byte sem sinal. Tanto o √≠ndice (1) quanto o √≠ndice+1 (2) devem ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. O elemento no topo da pilha de operandos deve ser do tipo double. Esse elemento √© retirado do topo da pilha e passa por uma convers√£o resultando em um valor'. O valor da vari√°vel no √≠ndice e no √≠ndice+1 recebem valor'.
 */
void manipulador_dstore_1 (Frame *frame){
    manipulador_xstore_n(frame, 1, TAG_DBL);
}

// 73 (0x49)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o dstore_2
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice (2) √© um byte sem sinal. Tanto o √≠ndice (2) quanto o √≠ndice+1 (3) devem ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. O elemento no topo da pilha de operandos deve ser do tipo double. Esse elemento √© retirado do topo da pilha e passa por uma convers√£o resultando em um valor'. O valor da vari√°vel no √≠ndice e no √≠ndice+1 recebem valor'.
 */
void manipulador_dstore_2 (Frame *frame){
    manipulador_xstore_n(frame, 2, TAG_DBL);
}

// 74 (0x4A)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o dstore_3
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice (3) √© um byte sem sinal. Tanto o √≠ndice (3) quanto o √≠ndice+1 (4) devem ser um ind√≠ce para o vetor de vari√°veis locais do frame atual. O elemento no topo da pilha de operandos deve ser do tipo double. Esse elemento √© retirado do topo da pilha e passa por uma convers√£o resultando em um valor'. O valor da vari√°vel no √≠ndice e no √≠ndice+1 recebem valor'.
 */
void manipulador_dstore_3 (Frame *frame){
    manipulador_xstore_n(frame, 3, TAG_DBL);
}

// 75 (0x4B)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o astore_0
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice (0) √© um byte sem sinal que deve ser um √≠ndice para o vetor de vari√°veis locais do frame atual. O elemento no topo da pilha de operandos deve ser do tipo returnAddress ou refer√™ncia. Esse elemento √© retirado do topo da pilha, e o valor da vari√°vel no √≠ndice recebe objectref.
 */
void manipulador_astore_0 (Frame *frame){
    manipulador_xstore_n(frame, 0, TAG_ARR);
}

// 76 (0x4C)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o astore_1
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice (1) √© um byte sem sinal que deve ser um √≠ndice para o vetor de vari√°veis locais do frame atual. O elemento no topo da pilha de operandos deve ser do tipo returnAddress ou refer√™ncia. Esse elemento √© retirado do topo da pilha, e o valor da vari√°vel no √≠ndice recebe objectref.
 */
void manipulador_astore_1 (Frame *frame){
    manipulador_xstore_n(frame, 1, TAG_ARR);
}

// 77 (0x4D)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o astore_2
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice (2) √© um byte sem sinal que deve ser um √≠ndice para o vetor de vari√°veis locais do frame atual. O elemento no topo da pilha de operandos deve ser do tipo returnAddress ou refer√™ncia. Esse elemento √© retirado do topo da pilha, e o valor da vari√°vel no √≠ndice recebe objectref.
 */
void manipulador_astore_2 (Frame *frame){
    manipulador_xstore_n(frame, 2, TAG_ARR);
}

// 78 (0x4E)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o astore_3
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O √≠ndice (3) √© um byte sem sinal que deve ser um √≠ndice para o vetor de vari√°veis locais do frame atual. O elemento no topo da pilha de operandos deve ser do tipo returnAddress ou refer√™ncia. Esse elemento √© retirado do topo da pilha, e o valor da vari√°vel no √≠ndice recebe objectref.
 */
void manipulador_astore_3 (Frame *frame){
    manipulador_xstore_n(frame, 3, TAG_ARR);
}

// 79 (0x4F)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o astore_3
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O arrayref deve ser do tipo refer√™ncia e deve referenciar um vetor cujos componentes s√£o do tipo inteiro. Tanto o √≠ndice quanto o valor devem ser do tipo inteiro. Arrayref, √≠ndice e o retirado do topo da pilha, e o valor da vari√°vel no √≠ndice recebe objectref.
 */
void manipulador_iastore (Frame *frame){
    manipulador_xastore(frame, TAG_INT);
}

// 80 (0x50)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o lastore
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O arrayref deve ser do tipo refer√™ncia e deve referenciar um vetor cujos componentes s√£o do tipo long. O √≠ndice deve ser do tipo inteiro e valor do tipo long. Arrayref, √≠ndice e o valor s√£o retirados do topo da pilha de operandos, a da vari√°vel no √≠ndice recebe valor.
 */
void manipulador_lastore (Frame *frame){
    manipulador_xastore(frame, TAG_LNG);
}

// 81 (0x51)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o fastore
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O arrayref deve ser do tipo refer√™ncia e deve referenciar um vetor cujos componentes s√£o do tipo flutuante. O √≠ndice deve ser do tipo inteiro e valor do tipo flutuante. Arrayref, √≠ndice e o valor s√£o retirados do topo da pilha de operandos. O valor do tipo flutuante passa por uma convers√£o, resultando em um valor'. A vari√°vel no √≠ndice recebe valor'.
 */
void manipulador_fastore (Frame *frame){
    manipulador_xastore(frame, TAG_FLT);
}

// 82 (0x52)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o dastore
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O arrayref deve ser do tipo refer√™ncia e deve referenciar um vetor cujos componentes s√£o do tipo double. O √≠ndice deve ser do tipo inteiro e valor do tipo double. Arrayref, √≠ndice e o valor s√£o retirados do topo da pilha de operandos. O valor do tipo double passa por uma convers√£o, resultando em um valor'. A vari√°vel no √≠ndice recebe valor'.
 */
void manipulador_dastore (Frame *frame){
    manipulador_xastore(frame, TAG_DBL);
}

// 83 (0x53)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o lastore
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O arrayref deve ser do tipo refer√™ncia e deve referenciar um vetor cujos componentes s√£o do tipo refer√™ncia. O √≠ndice deve ser do tipo inteiro e valor do tipo refer√™ncia. Arrayref, √≠ndice e o valor s√£o retirados do topo da pilha de operandos, a da vari√°vel no √≠ndice recebe valor.
 */
void manipulador_aastore (Frame *frame){
    manipulador_xastore(frame, TAG_REF);
}

// 84 (0x54)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o bastore
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O arrayref deve ser do tipo refer√™ncia e deve referenciar um vetor cujos componentes s√£o do tipo byte ou booleano. O √≠ndice e o valor devem ser tipo inteiro. Arrayref, √≠ndice e o valor s√£o retirados do topo da pilha de operandos. O valor do tipo inteiro √© truncado para um byte e armazenado no vetor na posi√ß√£o √≠ndice.
 */
void manipulador_bastore (Frame *frame){
    manipulador_xastore(frame, TAG_INT);
}

// 85 (0x55)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o castore
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O arrayref deve ser do tipo refer√™ncia e deve referenciar um vetor cujos componentes s√£o do tipo char. O √≠ndice e o valor devem ser tipo inteiro. Arrayref, √≠ndice e o valor s√£o retirados do topo da pilha de operandos. O valor do tipo inteiro √© truncado para um char e armazenado no vetor na posi√ß√£o √≠ndice.
 */
void manipulador_castore (Frame *frame){
    manipulador_xastore(frame, TAG_INT);
}

// 86 (0x56)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o sastore
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O arrayref deve ser do tipo refer√™ncia e deve referenciar um vetor cujos componentes s√£o do tipo short. O √≠ndice e o valor devem ser tipo inteiro. Arrayref, √≠ndice e o valor s√£o retirados do topo da pilha de operandos. O valor do tipo inteiro √© truncado para um short e armazenado no vetor na posi√ß√£o √≠ndice.
 */
void manipulador_sastore (Frame *frame){
    manipulador_xastore(frame, TAG_INT);
}

// 87 (0x57)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o pop
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Executa um pop no topo da pilha de operandos.
 */
void manipulador_pop (Frame *frame){
    frame->desempilhar();
    frame->pc++;
}

// 88 (0x58)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o pop
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Executa um ou dois pop no topo da pilha de operandos.
 */
void manipulador_pop2 (Frame *frame){
    Operando *op = frame->desempilhar();

    if ((op->tag != TAG_DBL) && (op->tag != TAG_LNG)){
        frame->desempilhar();
    }

    frame->pc++;
}

// 89 (0x59)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o dup
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Duplica o valor do operando do topo da pilha.
 */
void manipulador_dup (Frame *frame){
    Operando *op = frame->desempilhar();

    frame->empilhar(op);
    frame->empilhar(op);
    frame->pc++;
}

// 90 (0x5A)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o dup_x1
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Duplica o valor do operando do topo da pilha e o insere duas posi√ß√µes abaixo.
 */
void manipulador_dup_x1 (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    frame->empilhar(valor_1);
    frame->empilhar(valor_2);
    frame->empilhar(valor_1);

    frame->pc++;
}

// 91 (0x5B)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o dup_x2
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Duplica o valor do operando do topo da pilha e o insere duas ou tr√™s posi√ß√µes abaixo.
 */
void manipulador_dup_x2 (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    // Valor_1 := CAT_1 & Valor_2 := CAT_2
    if (((valor_1->tag != TAG_DBL) && (valor_1->tag != TAG_LNG))
            && ((valor_2->tag == TAG_DBL) || (valor_2->tag == TAG_LNG))){
        frame->empilhar(valor_1);
        frame->empilhar(valor_2);
        frame->empilhar(valor_1);

    // Valor_1 := CAT_1 & Valor_2 := CAT_1
    } else if (((valor_1->tag != TAG_DBL) && (valor_1->tag != TAG_LNG))
            && ((valor_2->tag != TAG_DBL) && (valor_2->tag != TAG_LNG))){
        Operando *valor_3 = frame->desempilhar();

        frame->empilhar(valor_1);
        frame->empilhar(valor_3);
        frame->empilhar(valor_2);
        frame->empilhar(valor_1);
    }

    frame->pc++;
}

// 92 (0x5C)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o dup2
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Duplica o valor do primeiro ou dos dois primeiros operandos da pilha.
 */
void manipulador_dup2 (Frame *frame){
    Operando *valor_1 = frame->desempilhar();

    // Valor_1 := CAT_2
    if ((valor_1->tag == TAG_DBL) || (valor_1->tag == TAG_LNG)){
        frame->empilhar(valor_1);
        frame->empilhar(valor_1);

    } else {
        Operando *valor_2 = frame->desempilhar();

        frame->empilhar(valor_2);
        frame->empilhar(valor_1);
        frame->empilhar(valor_2);
        frame->empilhar(valor_1);
    }

    frame->pc++;
}

// 93 (0x5D)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o dup2_x1
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Duplica o valor do primeiro ou dos dois primeiros operandos da pilha e insere duas ou tr√™s posi√ß√µes abaixo.
 */
void manipulador_dup2_x1 (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    // Valor_1 := CAT_2 & Valor_2 := CAT_1
    if (((valor_1->tag == TAG_DBL) || (valor_1->tag == TAG_LNG))
            && ((valor_2->tag != TAG_DBL) && (valor_2->tag != TAG_LNG))){
        frame->empilhar(valor_1);
        frame->empilhar(valor_2);
        frame->empilhar(valor_1);

    // Valor_1 := CAT_1 & Valor_2 := CAT_1
    } else if (((valor_1->tag != TAG_DBL) && (valor_1->tag != TAG_LNG))
            && ((valor_2->tag != TAG_DBL) && (valor_2->tag != TAG_LNG))){
        Operando *valor_3 = frame->desempilhar();

        frame->empilhar(valor_2);
        frame->empilhar(valor_1);
        frame->empilhar(valor_3);
        frame->empilhar(valor_2);
        frame->empilhar(valor_1);
    }

    frame->pc++;
}

// 94 (0x5E)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o dup2_x2
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Duplica o valor do primeiro ou dos dois primeiros operandos da pilha e insere duas, tr√™s ou quatro posi√ß√µes abaixo.
 */
void manipulador_dup2_x2 (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    // Valor_1 := CAT_2 & Valor_2 := CAT_2
    if (((valor_1->tag == TAG_DBL) || (valor_1->tag == TAG_LNG))
            && ((valor_2->tag == TAG_DBL) || (valor_2->tag == TAG_LNG))){
        frame->empilhar(valor_1);
        frame->empilhar(valor_2);
        frame->empilhar(valor_1);

    } else {
        Operando *valor_3 = frame->desempilhar();

        // Valor_1 := CAT_1 & Valor_2 := CAT_1 & Valor_3 := CAT_2
        if (((valor_1->tag != TAG_DBL) && (valor_1->tag != TAG_LNG))
            && ((valor_2->tag != TAG_DBL) && (valor_2->tag != TAG_LNG))
            && ((valor_3->tag == TAG_DBL) || (valor_3->tag == TAG_LNG))){
            frame->empilhar(valor_2);
            frame->empilhar(valor_1);
            frame->empilhar(valor_3);
            frame->empilhar(valor_2);
            frame->empilhar(valor_1);

        // Valor_1 := CAT_2 & Valor_2 := CAT_1 & Valor_3 := CAT_1
        } else if (((valor_1->tag == TAG_DBL) || (valor_1->tag == TAG_LNG))
            && ((valor_2->tag != TAG_DBL) && (valor_2->tag != TAG_LNG))
            && ((valor_3->tag != TAG_DBL) && (valor_3->tag != TAG_LNG))){
            frame->empilhar(valor_1);
            frame->empilhar(valor_3);
            frame->empilhar(valor_2);
            frame->empilhar(valor_1);

        // Valor_1 := CAT_1 & Valor_2 := CAT_1 & Valor_3 := CAT_1
        } else {
            Operando *valor_4 = frame->desempilhar();

            frame->empilhar(valor_2);
            frame->empilhar(valor_1);
            frame->empilhar(valor_4);
            frame->empilhar(valor_3);
            frame->empilhar(valor_2);
            frame->empilhar(valor_1);
        }
    }

    frame->pc++;
}

// 95 (0x5F)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o swap
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Troca a posi√ß√£o do primeiro com o segundo operador na pilha.
 */
void manipulador_swap (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    frame->empilhar(valor_1);
    frame->empilhar(valor_2);

    frame->pc++;
}

// 96 (0x60)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o iadd
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Adiciona um inteiro.
 */
void manipulador_iadd (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    int i1 = valor_1->tipo_int,
        i2 = valor_2->tipo_int;

    exibir_se_verboso("\tA somar " + std::to_string(i2) + " e " + std::to_string(i1));

    Operando *resultado = new Operando();
    resultado->tag = TAG_INT;
    resultado->tipo_int = i2 + i1;

    frame->empilhar(resultado);
    frame->pc++;
}

// 97 (0x61)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o ladd
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Adiciona um long.
 */
void manipulador_ladd (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    long l2 = (long) valor_2->tipo_long,
         l1 = (long) valor_1->tipo_long;

    exibir_se_verboso("\tA somar " + std::to_string(l2) + " e " + std::to_string(l1));

    Operando *resultado = new Operando();
    resultado->tag = TAG_LNG;
    resultado->tipo_long = l2 + l1;

    frame->empilhar(resultado);
    frame->pc++;
}

// 98 (0x62)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o fadd
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Adiciona um flutuante.
 */
void manipulador_fadd (Frame *frame){
    Operando *valor_2 = frame->desempilhar();
    Operando *valor_1 = frame->desempilhar();

    float f1 = valor_1->tipo_float,
          f2 = valor_2->tipo_float;

    exibir_se_verboso("\tA somar " + std::to_string(f1) + " e " + std::to_string(f2));

    Operando *resultado = new Operando();
    resultado->tag = TAG_FLT;
    resultado->tipo_float = f1 + f2;

    frame->empilhar(resultado);
    frame->pc++;
}

// 99 (0x63)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o dadd
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Adiciona um double.
 */
void manipulador_dadd (Frame *frame){
    Operando *valor_2 = frame->desempilhar();
    Operando *valor_1 = frame->desempilhar();

    double d1 = valor_1->tipo_double,
           d2 = valor_2->tipo_double;

    exibir_se_verboso("\tA somar " + std::to_string(d1) + " e " + std::to_string(d2));

    Operando *resultado = new Operando();
    resultado->tag = TAG_DBL;
    resultado->tipo_double = d1 + d2;

    frame->empilhar(resultado);
    frame->pc++;
}

// 100 (0x64)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o isub
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Subtrai um inteiro.
 */
void manipulador_isub (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    Operando *resultado = new Operando();
    resultado->tag = TAG_INT;
    resultado->tipo_int = valor_2->tipo_int - valor_1->tipo_int;

    frame->empilhar(resultado);
    frame->pc++;
}

// 101 (0x65)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o lsub
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Subtrai um long.
 */
void manipulador_lsub (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    Operando* resultado = new Operando();
    resultado->tag = TAG_LNG;
    resultado->tipo_long = valor_2->tipo_long - valor_1->tipo_long;

    frame->empilhar(resultado);
    frame->pc++;
}

// 102 (0x66)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o fsub
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Subtrai um flutuante.
 */
void manipulador_fsub (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();
    float fvalor_1, fvalor_2;

    std::memcpy(&fvalor_1,&valor_1->tipo_float,sizeof(float));
    std::memcpy(&fvalor_2,&valor_2->tipo_float,sizeof(float));
    fvalor_2 -= fvalor_1;

    Operando *resultado = new Operando();
    resultado->tag = TAG_FLT;

    memcpy(&resultado->tipo_float, &fvalor_2, sizeof(float));

    frame->empilhar(resultado);
    frame->pc++;
}

// 103 (0x67)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o dsub
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Subtrai um double.
 */
void manipulador_dsub (Frame *frame){
    Operando *valor_2 = frame->desempilhar();
    Operando *valor_1 = frame->desempilhar();

    Operando *resultado = new Operando();
    resultado->tag = TAG_DBL;
    resultado->tipo_double = valor_1->tipo_double - valor_2->tipo_double;

    frame->empilhar(resultado);
    frame->pc++;
}

// 104 (0x68)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o imul
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Multiplica um inteiro.
 */
void manipulador_imul (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    Operando *resultado = new Operando();
    resultado->tag = TAG_INT;
    resultado->tipo_int = valor_1->tipo_int * valor_2->tipo_int;

    frame->empilhar(resultado);
    frame->pc++;
}

// 105 (0x69)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o lmul
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Multiplica um long.
 */
void manipulador_lmul (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    Operando *resultado = new Operando();
    resultado->tag = TAG_LNG;
    resultado->tipo_long = valor_1->tipo_long * valor_2->tipo_long;

    frame->empilhar(resultado);
    frame->pc++;
}

// 106 (0x6A)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o fmul
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Multiplica um flutuante.
 */
void manipulador_fmul (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    float fvalor_1, fvalor_2;
    std::memcpy(&fvalor_1, &valor_1->tipo_float, sizeof(float));
    std::memcpy(&fvalor_2, &valor_2->tipo_float, sizeof(float));
    fvalor_1 *= fvalor_2;

    Operando *resultado = new Operando();
    resultado->tag = TAG_FLT;
    memcpy(&resultado->tipo_float, &fvalor_1, sizeof(float));

    frame->empilhar(resultado);
    frame->pc++;
}

// 107 (0x6B)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o dmul
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Multiplica um double.
 */
void manipulador_dmul (Frame *frame){
    Operando *valor_2 = frame->desempilhar();
    Operando *valor_1 = frame->desempilhar();

    Operando *resultado = new Operando();
    resultado->tag = TAG_DBL;
    resultado->tipo_double = valor_1->tipo_double * valor_2->tipo_double;

    frame->empilhar(resultado);
    frame->pc++;
}

// 108 (0x6C)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o idiv
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Divide um inteiro.
 */
void manipulador_idiv (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    Operando *resultado = new Operando();
    resultado->tag = TAG_INT;
    resultado->tipo_int = floor(valor_2->tipo_int / valor_1->tipo_int);

    frame->empilhar(resultado);
    frame->pc++;
}

// 109 (0x6D)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o ldiv
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Divide um long.
 */
void manipulador_ldiv (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    Operando *resultado = new Operando();
    resultado->tag = TAG_LNG;
    resultado->tipo_int = floor(valor_2->tipo_long / valor_1->tipo_long);

    frame->empilhar(resultado);
    frame->pc++;
}

// 110 (0x6E)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o fdiv
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Divide um flutuante.
 */
void manipulador_fdiv (Frame *frame){
    Operando *valor_2 = frame->desempilhar();
    Operando *valor_1 = frame->desempilhar();

    float f1 = valor_1->tipo_float,
          f2 = valor_2->tipo_float;

    exibir_se_verboso("\tA dividir " + std::to_string(f1) + " por " + std::to_string(f2));

    Operando *resultado = new Operando();
    resultado->tag = TAG_FLT;
    resultado->tipo_float = f1 / f2;

    frame->empilhar(resultado);
    frame->pc++;
}

// 111 (0x6F)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o ddiv
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Divide um double.
 */
void manipulador_ddiv (Frame *frame){
    Operando *valor_2 = frame->desempilhar();
    Operando *valor_1 = frame->desempilhar();

    Operando *resultado = new Operando();
    resultado->tag = TAG_DBL;
    resultado->tipo_double = valor_1->tipo_double / valor_2->tipo_double;

    frame->empilhar(resultado);
    frame->pc++;
}

// 112 (0x70)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o irem
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Ambos valor1 e valor2 devem ser do tipo inteiro. Os valores s√£o retirados do topo da pilha de operandos. O resultando (inteiro) √© valor1 - (valor1 / valor2) * valor2. O resultado √© colocado no topo da pilha.
 */
void manipulador_irem (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    Operando *resultado = new Operando();
    resultado->tag = TAG_INT;
    resultado->tipo_int = valor_2->tipo_int % valor_1->tipo_int;

    frame->empilhar(resultado);
    frame->pc++;
}

// 113 (0x71)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o lrem
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Ambos valor1 e valor2 devem ser do tipo long. Os valores s√£o retirados do topo da pilha de operandos. O resultando (long) √© valor1 - (valor1 / valor2) * valor2. O resultado √© colocado no topo da pilha.
 */
void manipulador_lrem (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    Operando *resultado = new Operando();
    resultado->tag = TAG_LNG;
    resultado->tipo_int = valor_2->tipo_long % valor_1->tipo_long;

    frame->empilhar(resultado);
    frame->pc++;
}

// 114 (0x72)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o frem
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Ambos valor1 e valor2 devem ser do tipo flutuante. Os valores s√£o retirados do topo da pilha de operandos. O resultando (flutuante) √© valor1 - (valor1 / valor2) * valor2. O resultado √© colocado no topo da pilha.
 */
void manipulador_frem (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    float fvalor_1, fvalor_2;
    std::memcpy(&fvalor_1,&valor_1->tipo_float,sizeof(float));
    std::memcpy(&fvalor_2,&valor_2->tipo_float,sizeof(float));
    fvalor_1 = fmod(fvalor_2, fvalor_1);

    Operando *resultado = new Operando();
    resultado->tag = TAG_FLT;
    memcpy(&resultado->tipo_float, &fvalor_1, sizeof(float));

    frame->empilhar(resultado);
    frame->pc++;
}

// 115 (0x73)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o drem
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Ambos valor1 e valor2 devem ser do tipo double. Os valores s√£o retirados do topo da pilha de operandos. O resultando (double) √© valor1 - (valor1 / valor2) * valor2. O resultado √© colocado no topo da pilha.
 */
void manipulador_drem (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    Operando *resultado = new Operando();
    resultado->tag = TAG_DBL;
    resultado->tipo_double = fmod(valor_2->tipo_double, valor_1->tipo_double);

    frame->empilhar(resultado);
    frame->pc++;
}

// 116 (0x74)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o ineg
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O valor deve ser do tipo inteiro. O valor √© retirado do topo da pilha de operandos. O valor √© subtra√≠do de zero para obter o negativo. O resultado √© colocado no topo da pilha.
 */
void manipulador_ineg (Frame *frame){
    Operando *valor = frame->desempilhar();

    Operando *resultado = new Operando();
    resultado->tag = TAG_INT;
    resultado->tipo_int = (~valor->tipo_int) + 1;    frame->empilhar(resultado);
    frame->pc++;
}

// 117 (0x75)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o ineg
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O valor deve ser do tipo long. O valor √© retirado do topo da pilha de operandos. O valor √© subtra√≠do de zero para obter o negativo. O resultado √© colocado no topo da pilha.
 */
void manipulador_lneg (Frame *frame){
    Operando *valor = frame->desempilhar();

    Operando *resultado = new Operando();
    resultado->tag = TAG_LNG;
    resultado->tipo_long = (~valor->tipo_long) + 1;    frame->empilhar(resultado);
    frame->pc++;
}

// 118 (0x76)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o fneg
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O valor deve ser do tipo flutuante. O valor √© retirado do topo da pilha de operandos. O valor √© subtra√≠do de zero para obter o negativo. O resultado √© colocado no topo da pilha.
 */
void manipulador_fneg (Frame *frame){
    Operando *valor = frame->desempilhar();
    float valor1, valor2;

    std::memcpy(&valor1, &valor->tipo_float, sizeof(float));

    valor2 = -valor1;

    Operando *resultado = new Operando();
    resultado->tag = TAG_FLT;
    std::memcpy(&resultado->tipo_float, &valor2, sizeof(float));    frame->empilhar(resultado);
    frame->pc++;
}

// 119 (0x77)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o dneg
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * O valor deve ser do tipo double. O valor √© retirado do topo da pilha de operandos. O valor √© subtra√≠do de zero para obter o negativo. O resultado √© colocado no topo da pilha.
 */
void manipulador_dneg (Frame *frame){
    Operando *valor = frame->desempilhar();

    Operando *resultado = new Operando();
    resultado->tag = TAG_DBL;
    resultado->tipo_double = valor->tipo_double * -1;    frame->empilhar(resultado);
    frame->pc++;
}

// 120 (0x78)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o ishl
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Ambos valor1 e valor2 devem ser do tipo inteiro. Os valores s√£o retirados do topo da pilha de operandos. Um resultado inteiro √© calculado a partir do shift para a esquerda do valor1 em S bits, com extens√£o de sinal, onde S √© o n√∫mero equivalente aos 5 √∫ltimos bits do valor2. O resultado √© colocado no topo da pilha.
 */
void manipulador_ishl (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    u4 ivalor1 = valor_1->tipo_int;
    u4 ivalor2 = valor_2->tipo_int;

    ivalor1 &= 0x0000001F;

    Operando *resultado = new Operando();
    resultado->tag = TAG_INT;
    resultado->tipo_int = ivalor2 << ivalor1;

    frame->empilhar(resultado);
    frame->pc++;
}

// 121 (0x79)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o lshl
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Valor1 deve ser um long e valor2 deve ser do tipo inteiro. Os valores s√£o retirados do topo da pilha de operandos. Um resultado long √© calculado a partir do shift para a esquerda do valor1 em S bits, com extens√£o de sinal, onde S √© o n√∫mero equivalente aos 6 √∫ltimos bits do valor2. O resultado √© colocado no topo da pilha.
 */
void manipulador_lshl (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    u8 lvalor1 = valor_1->tipo_long;
    u8 lvalor2 = valor_2->tipo_long;

    lvalor1 &= 0x0000003F;

    Operando *resultado = new Operando();
    resultado->tag = TAG_LNG;
    resultado->tipo_long = lvalor2 << lvalor1;

    frame->empilhar(resultado);
    frame->pc++;

}

// 122 (0x7A)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o lshl
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Valor1 deve ser um long e valor2 deve ser do tipo inteiro. Os valores s√£o retirados do topo da pilha de operandos. Um resultado long √© calculado a partir do shift para a direita do valor1 em S bits, com extens√£o de sinal, onde S √© o n√∫mero equivalente aos 6 √∫ltimos bits do valor2. O resultado √© colocado no topo da pilha.
 */
void manipulador_ishr (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    u4 ivalor1 = valor_1->tipo_int;
    u4 ivalor2 = valor_2->tipo_int;

    ivalor1 &= 0x0000001F;

    Operando *resultado = new Operando();
    resultado->tag = TAG_INT;
    resultado->tipo_int = ivalor2 >> ivalor1;

    frame->empilhar(resultado);
    frame->pc++;
}

// 123 (0x7B)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o ishr
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Ambos valor1 e valor2 devem ser do tipo inteiro. Os valores s√£o retirados do topo da pilha de operandos. Um resultado inteiro √© calculado a partir do shift para a direita do valor1 em S bits, com extens√£o de sinal, onde S √© o n√∫mero equivalente aos 5 √∫ltimos bits do valor2. O resultado √© colocado no topo da pilha.
 */
void manipulador_lshr (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    u8 lvalor1 = valor_1->tipo_long;
    u8 lvalor2 = valor_2->tipo_long;

    lvalor1 &= 0x0000003F;

    Operando *resultado = new Operando();
    resultado->tag = TAG_LNG;
    resultado->tipo_long = lvalor2 >> lvalor1;

    frame->empilhar(resultado);
    frame->pc++;
}

// 124 (0x7C)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o iushr
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Ambos valor1 e valor2 devem ser do tipo inteiro. Os valores s√£o retirados do topo da pilha de operandos. Um resultado inteiro √© calculado a partir do shift para a direita do valor1 em S bits, sem sinal, onde S √© o n√∫mero equivalente aos 5 √∫ltimos bits do valor2. O resultado √© colocado no topo da pilha.
 */
void manipulador_iushr (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    u4 ivalor1 = valor_1->tipo_int;
    u4 ivalor2 = valor_2->tipo_int;

    ivalor2 &= 0x0000001F;

    Operando *resultado = new Operando();
    resultado->tag = TAG_INT;
    resultado->tipo_int = ivalor1 >> ivalor2;

    frame->empilhar(resultado);
    frame->pc++;
}

// 125 (0x7D)
/**
 * @brief Fun√ß√£o de opera√ß√£o da instru√ß√£o lushr
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 * Valor1 deve ser um long e valor2 deve ser do tipo inteiro. Os valores s√£o retirados do topo da pilha de operandos. Um resultado long √© calculado a partir do shift para a direita, de maneira l√≥gica, do valor1 em S bits, sem extens√£o de sinal, onde S √© o n√∫mero equivalente aos 6 √∫ltimos bits do valor2. O resultado √© colocado no topo da pilha.
 */
void manipulador_lushr (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    u8 lvalor1 = valor_1->tipo_long;
    u8 lvalor2 = valor_2->tipo_long;

    lvalor2 &= 0x0000003F;

    Operando *resultado = new Operando();
    resultado->tag = TAG_LNG;
    resultado->tipo_long = lvalor1 >> lvalor2;

    frame->empilhar(resultado);
    frame->pc++;
}

// 126 (0x7E)
/**
 * @brief Realiza a opera√ß√£o iand com vari√°veis de tipo inteiro
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 *
 *  O valor1 e o valor2 devem ser do tipo inteiro. Eles s√£o removidos da pilha de operandos. Um resultado inteiro √© calculado usando AND (bit a bit) de valor1 e valor2. O resultado √© enviado para a pilha de operandos.
 */
void manipulador_iand (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    int resultado = valor_1->tipo_int & valor_2->tipo_int;

    std::memcpy(&valor_1->tipo_int, &resultado, sizeof(int));

    frame->empilhar(valor_1);
    frame->pc++;
}

// 127 (0x7F)
/**
 * @brief Realiza a opera√ß√£o and com vari√°veis de tipo longo
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor1 e o valor2 devem ser do tipo longo. Eles s√£o removidos da pilha de operandos. Um resultado longo √© calculado usando AND bit a bit de valor1 e valor2. O resultado √© enviado para a pilha de operandos.
 */
void manipulador_land (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    u8 resultado = valor_1->tipo_long & valor_2->tipo_long;

    std::memcpy(&valor_1->tipo_long, &resultado, sizeof(u8));

    frame->empilhar(valor_1);
    frame->pc++;
}

// 128 (0x80)
/**
 * @brief Realiza a opera√ß√£o or com vari√°veis de tipo inteiro
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor1 e o valor2 devem ser do tipo inteiro. Eles s√£o removidos da pilha de operandos. Um resultado inteiro √© calculado usando o OR inclusivo bit a bit de value1 e value2. O resultado √© enviado para a pilha de operandos.
 */
void manipulador_ior (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    int resultado = valor_1->tipo_int | valor_2->tipo_int;

    std::memcpy(&valor_1->tipo_int, &resultado, sizeof(u4));

    frame->empilhar(valor_1);
    frame->pc++;
}

// 129 (0x81)
/**
 * @brief Realiza a opera√ß√£o or com vari√°veis de tipo longo
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor1 e o valor2 devem ser do tipo longo. Eles s√£o removidos da pilha de operandos. Um resultado longo √© calculado usando o OR inclusivo bit a bit de value1 e value2. O resultado √© enviado para a pilha de operandos.
 */
void manipulador_lor (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    u8 resultado = valor_1->tipo_long | valor_2->tipo_long;

    std::memcpy(&valor_1->tipo_long, &resultado, sizeof(u8));

    frame->empilhar(valor_1);
    frame->pc++;
}

// 130 (0x82)
/**
 * @brief Realiza a opera√ß√£o xor com vari√°veis de tipo inteiro
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor1 e o valor2 devem ser do tipo inteiro. Eles s√£o removidos da pilha de operandos. Um resultado inteiro √© calculado utilizando o OR bit a bit exclusivo de value1 e value2. O resultado √© enviado para a pilha de operandos.
 */
void manipulador_ixor (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    int resultado = valor_1->tipo_int ^ valor_2->tipo_int;

    std::memcpy(&valor_1->tipo_int, &resultado, sizeof(u4));

    frame->empilhar(valor_1);
    frame->pc++;
}

// 131 (0x83)
/**
 * @brief Realiza a opera√ß√£o xor com vari√°veis de tipo longo
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor1 e o valor2 devem ser do tipo longo. Eles s√£o removidos da pilha de operandos. Um resultado longo √© calculado usando o OR exclusivo bit a bit de value1 e value2. O resultado √© enviado para a pilha de operandos.
 */
void manipulador_lxor (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    u8 resultado = valor_1->tipo_long ^ valor_2->tipo_long;

    std::memcpy(&valor_1->tipo_long, &resultado, sizeof(u8));

    frame->empilhar(valor_1);
    frame->pc++;
}

// 132 (0x84)
/**
 * @brief Incrementa a vari√°vel local por uma constante
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O √≠ndice √© um unsigned byte que deve ser um √≠ndice no array de vari√°veis locais do frame atual. O const √© um unsigned byte imediato. A vari√°vel local no √≠ndice deve conter um inteiro. O valor constante √© primeiro estendido para um sinal de inteiro e, em seguida, a vari√°vel local no √≠ndice √© incrementada por esse valor.
 */
void manipulador_iinc (Frame *frame){
    u1 indice = frame->get_prox_byte();
    int8_t valor = (int) frame->get_prox_byte();

    manipulador_iincx (frame, indice, valor);
}

/**
 * @brief Converte inteiro para longo
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor do topo da pilha de operandos deve ser do tipo inteiro. Ele √© retirado da pilha de operandos e estendido para um resultado longo. Esse resultado √© enviado para a pilha de operandos.
 */
// 133 (0x85)
void manipulador_i2l (Frame *frame){
    Operando *op = new Operando();
    Operando *topo = frame->desempilhar();

    exibir_se_verboso("\tA converter " + std::to_string((int) topo->tipo_int) + " para long");

    op->tipo_long = (long) ((int) topo->tipo_int);
    op->tag = TAG_LNG;

    frame->empilhar(op);
    frame->pc++;
}

// 134 (0x86)
/**
 * @brief Converte inteiro para flutuante
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor do topo da pilha de operandos deve ser do tipo inteiro. Ele √© retirado da pilha de operandos e convertido no resultado em flutuante usando o IEEE 754 arredondado para o modo mais pr√≥ximo. O resultado √© empilhado na pilha de operandos.
 */
void manipulador_i2f (Frame *frame){
    Operando *op = new Operando();
    Operando *topo = frame->desempilhar();

    exibir_se_verboso("\tA converter " + std::to_string((int) topo->tipo_int) + " para float");

    op->tipo_float = (float) ((int) topo->tipo_int);
    op->tag = TAG_FLT;

    frame->empilhar(op);
    frame->pc++;
}

// 135 (0x87)
/**
 * @brief Converte inteiro para double
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor do topo da pilha de operandos deve ser do tipo inteiro. Ele √© retirado da pilha de operandos e convertido em um resultado double. O resultado √© empilhado na pilha de operandos.
 */
void manipulador_i2d (Frame *frame){
    Operando *op = new Operando();
    Operando *topo = frame->desempilhar();

    exibir_se_verboso("\tA converter " + std::to_string((int) topo->tipo_int) + " para double");

    op->tipo_double = (double) ((int) topo->tipo_int);
    op->tag = TAG_DBL;

    frame->empilhar(op);
    frame->pc++;
}

// 136 (0x88)
/**
 * @brief Converte longo para inteiro
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor do topo da pilha de operandos deve ser do tipo longo. Ele √© retirado da pilha de operandos e convertido em um resultado inteiro, retirando os 32 bits de ordem baixa do valor longo e descartando os 32 bits de ordem superior. O resultado √© empilhado na pilha de operandos.
 */
void manipulador_l2i (Frame *frame){
    Operando *op = new Operando();
    Operando *topo = frame->desempilhar();

    exibir_se_verboso("\tA converter " + std::to_string((long) topo->tipo_long) + " para int");

    op->tipo_int = (int) ((long) topo->tipo_long);
    op->tag = TAG_INT;

    frame->empilhar(op);
    frame->pc++;
}

// 137 (0x89)
/**
 * @brief Converte longo para flutuante
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor do topo da pilha de operandos deve ser do tipo longo. Ele √© retirado da pilha de operandos e convertido em um resultado flutuante usando o IEEE 754 arredondado para o modo mais pr√≥ximo. O resultado √© empilhado na pilha de operandos.
 */
void manipulador_l2f (Frame *frame){
    Operando *op = new Operando();
    Operando *topo = frame->desempilhar();

    exibir_se_verboso("\tA converter " + std::to_string((long) topo->tipo_long) + " para float");

    op->tipo_float = (float) ((long) topo->tipo_long);
    op->tag = TAG_FLT;

    frame->empilhar(op);
    frame->pc++;
}

// 138 (0x8A)
/**
 * @brief Converte longo para double
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor do topo da pilha de operandos deve ser do tipo longo. Ele √© retirado da pilha de operandos e convertido em um resultado double usando o IEEE 754 arredondado para o modo mais pr√≥ximo. O resultado √© empilhado na pilha de operandos.
 */
void manipulador_l2d (Frame *frame){
    Operando *op = new Operando();
    Operando *topo = frame->desempilhar();

    exibir_se_verboso("\tA converter " + std::to_string((long) topo->tipo_long) + " para double");

    op->tipo_double = (double) ((long) topo->tipo_long);
    op->tag = TAG_DBL;

    frame->empilhar(op);
    frame->pc++;
}

// 139 (0x8B)
/**
 * @brief Converte flutuante para inteiro
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor do topo da pilha de operandos deve ser do tipo longo. Ele √© retirado da pilha de operandos e convertido em um resultado double usando o IEEE 754 arredondado para o modo mais pr√≥ximo. O resultado √© empilhado na pilha de operandos.
 */
void manipulador_f2i (Frame *frame){
    Operando *op = new Operando();
    Operando *topo = frame->desempilhar();

    exibir_se_verboso("\tA converter " + std::to_string((float) topo->tipo_float) + " para int");

    op->tipo_int = (int) ((float) topo->tipo_float);
    op->tag = TAG_INT;

    frame->empilhar(op);
    frame->pc++;
}

// 140 (0x8C)
/**
 * @brief Converte flutuante para longo
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor do topo da pilha de operandos deve ser do tipo flutuante. Ele √© retirado da pilha de operandos e sofre convers√£o de valores0. Esse valor √© convertido em um resultado do tipo inteiro e o resultado √© empilhado na pilha de operandos
 * Se esse valor n√£o for num√©rico, o resultado da convers√£o ser√° um inteiro 0.
 * Caso contr√°rio, se esse valor n√£o for um infinito, ele ser√° arredondado para um valor inteiro V, arredondando para zero usando IEEE 754 arredondado para o modo zero.
 * Se esse valor inteiro puder ser representado como inteiro, o resultado ser√° o pr√≥prio valor.
 * Caso contr√°rio, se esse valor for muito pequeno (um valor negativo de grande magnitude ou infinito negativo) e o resultado √© o menor valor represent√°vel do tipo inteiro ou o valor deve ser grande (um valor positivo de grade magnitude ou positivo) e o resultado √© o maior valor respons√°vel do tipo inteiro
 * 
 */
void manipulador_f2l (Frame *frame){
    Operando *op = new Operando();
    Operando *topo = frame->desempilhar();

    exibir_se_verboso("\tA converter " + std::to_string((float) topo->tipo_float) + " para long");

    op->tipo_long = (long) ((float) topo->tipo_float);
    op->tag = TAG_LNG;

    frame->empilhar(op);
    frame->pc++;
}

// 141 (0x8D)
/**
 * @brief Converte flutuante para double
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor do topo da pilha de operandos deve ser do tipo flutuante. Ele √© retirado da pilha de operandos e sofre convers√£o de conjunto de valores, resultando em um valor. Ent√£o o este valor √© convertido em um resultado double. Este resultado empilhado na pilha de operandos.
 * 
 */
void manipulador_f2d (Frame *frame){
    Operando *op = new Operando();
    Operando *topo = frame->desempilhar();

    exibir_se_verboso("\tA converter " + std::to_string((float) topo->tipo_float) + " para double");

    op->tipo_double = (double) ((float) topo->tipo_float);
    op->tag = TAG_DBL;

    frame->empilhar(op);
    frame->pc++;
}


// 142 (0x8E)
/**
 * @brief Converte double para inteiro
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor do topo da pilha de operandos deve ser do tipo double. Ele √© retirado da pilha de operandos e sofre convers√£o resultando em um valor. Ent√£o o valor √© convertido em inteiro e empilhado na pilha de operandos.
 * Se o valor n√£o √© n√£o num√©rico o resultado da convers√µa √© um inteiro 0.
 * Caso contr√°rio, se o valor n√£o for um infinito, ele ser√° arredondado para um valor inteiro V, arredondando para zero usando IEEE 754 arredondado para o modo zero. Se esse valor inteiro V puder ser representado como um inteiro, o resultado ser√° o valor V. 
 * Caso contr√°rio, o valor deve ser muito pequeno (um valor negativo de grande magnitude ou infinito negativo) e o resultado √© o menor valor represent√°vel do tipo inteiro ou o valor deve ser muito grande (um valor positivo de grande magnitude ou infinito positivo) e o resultado √© o maior valor represent√°vel do tipo inteiro.
 * 
 */
void manipulador_d2i (Frame *frame){
    Operando *op = new Operando();
    Operando *topo = frame->desempilhar();

    exibir_se_verboso("\tA converter " + std::to_string((double) topo->tipo_double) + " para int");

    op->tipo_int = (int) ((double) topo->tipo_double);
    op->tag = TAG_INT;

    frame->empilhar(op);
    frame->pc++;
}

// 143 (0x8F)
/**
 * @brief Converte double para longo
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor do topo da pilha de operandos deve ser do tipo double. Ele √© retirado da pilha de operandos e sofre convers√£o resultando em um valor. Ent√£o o valor √© convertido em longo
 * O resultado √© empilhado na pilha de operandos. 
 * Se o valor n√£o √© n√£o num√©rico o resultado da convers√£o √© um longo 0.
 * Caso contr√°rio, se o valor n√£o for um infinito, ele ser√° arredondado para um valor inteiro V, arredondando para zero usando IEEE 754 arredondado para o modo zero. Se esse valor inteiro V puder ser representado como um inteiro, o resultado ser√° o valor longo V. 
 * Caso contr√°rio, o valor deve ser muito pequeno (um valor negativo de grande magnitude ou infinito negativo) e o resultado √© o menor valor represent√°vel do tipo longo ou o valor deve ser muito grande (um valor positivo de grande magnitude ou infinito positivo) e o resultado √© o maior valor represent√°vel do tipo longo.
 * 
 */
void manipulador_d2l (Frame *frame){
    Operando *op = new Operando();
    Operando *topo = frame->desempilhar();

    exibir_se_verboso("\tA converter " + std::to_string((double) topo->tipo_double) + " para long");

    op->tipo_long = (long) ((double) topo->tipo_double);
    op->tag = TAG_LNG;

    frame->empilhar(op);
    frame->pc++;
}

// 144 (0x90)
/**
 * @brief Converte double para flutuante
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor do topo da pilha de operandos deve ser do tipo double. Ele √© retirado da pilha de operandos e sofre convers√£o de conjunto de valores, resultando em um valor. Em seguida, este valor √© convertido em um resultado em flutuante usando o IEEE 754 arredondado para o modo mais pr√≥ximo. O resultado √© enviado para a pilha de operandos.
 * Onde uma instru√ß√£o d2f √© FP estrita, o resultado da convers√£o √© sempre arredondado para o valor represent√°vel mais pr√≥ximo no valor flutuante definido.
 * Onde uma instru√ß√£o d2f n√£o √© estrita para FP, o resultado da convers√£o pode ser obtido do valor do expoente flutuante estendido. n√£o √© necess√°rio o arredondado para o valor represent√°vel mais pr√≥ximo no conjunto de valores flutuantes.
 * Um valor finito muito pequeno para ser representado como um flutuate √© convertido em zero do mesmo sinal. Um valor finito muito grande para ser representado como um flutuante √© convertido em um infinito do mesmo sinal. Um NaN duplo √© convertido em NaN flutuante.
 */
void manipulador_d2f (Frame *frame){
    Operando *op = new Operando();
    Operando *topo = frame->desempilhar();

    exibir_se_verboso("\tA converter " + std::to_string((double) topo->tipo_double) + " para float");

    op->tipo_float = (float) ((double) topo->tipo_double);
    op->tag = TAG_FLT;

    frame->empilhar(op);
    frame->pc++;
}

// 145 (0x91)
/**
 * @brief Converte inteiro para byte
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor do topo da pilha de operandos deve ser do tipo inteiro. Ele √© retirado da pilha de operandos, truncado para um byte e depois estendido para um resultado inteiro. Esse resultado √© enviado para a pilha de operandos.
 */
void manipulador_i2b (Frame *frame){
    Operando *op = frame->desempilhar();

    int valor = (int8_t) op->tipo_int;

    std::memcpy(&op->tipo_byte, &valor, sizeof(u4));

    frame->empilhar(op);
    frame->pc++;
}

// 146 (0x92)
/**
 * @brief Converte inteiro para character
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor do topo da pilha de operandos deve ser do tipo inteiro. Ele √© retirado da pilha de operandos, truncado para char e estendido em zero a um resultado int. Esse resultado √© enviado para a pilha de operandos.
 */
void manipulador_i2c (Frame *frame){
    Operando *op = new Operando();
    Operando *topo = frame->desempilhar();

    exibir_se_verboso("\tA converter " + std::to_string((int) topo->tipo_int) + " para char");

    char valor_convertido =  (char) topo->tipo_int;

    memcpy(&op->tipo_char,&valor_convertido,sizeof(char));

    op->tag = TAG_CHR;

    frame->empilhar(op);
    frame->pc++;
}

// 147 (0x93)
/**
 * @brief Converte inteiro para short
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor na parte superior da pilha de operandos deve ser do tipo inteiro. Ele √© retirado da pilha de operandos, truncado para um short e estendido para um resultado inteiro. Esse resultado √© empilhado na pilha de operandos.
 */
void manipulador_i2s (Frame *frame){
    Operando *op = new Operando();
    Operando *topo = frame->desempilhar();

    exibir_se_verboso("\tA converter " + std::to_string((int) topo->tipo_int) + " para short");

    op->tipo_int = (short) ((int) topo->tipo_int);
    op->tag = TAG_INT;

    frame->empilhar(op);
    frame->pc++;
}

// 148 (0x94)
/**
 * @brief Compara dois valores do tipo longo
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor1 e o valor2 devem ser do tipo longo. Ambos s√£o removidos da pilha de operandos e uma compara√ß√£o de n√∫mero inteiro sem sinal √© executada. Se o valor1 for maior que o valor2, o valor inteiro 1 ser√° empilhado na pilha de operandos. Se o valor1 for igual ao valor2, o valor int 0 ser√° empilhado na pilha de operandos. Se o valor1 for menor que o valor2, o valor inteiro -1 ser√° empurrado para a pilha de operandos.
 * 
 */

void manipulador_lcmp (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    int resultado = 0;

    if (valor_1->tipo_long < valor_2->tipo_long)
        resultado = 1;

    else if (valor_1->tipo_long > valor_2->tipo_long)
        resultado = -1;

    std::memcpy(&valor_1->tipo_int, &resultado, sizeof(u4));
    valor_1->tag = TAG_INT;    frame->empilhar(valor_1);
    frame->pc++;
}

// 149 (0x95)
/**
 * @brief Compara dois valores do tipo float
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor1 e o valor2 devem ser do tipo longo. Ambos s√£o removidos da pilha de operandos e uma compara√ß√£o de n√∫mero inteiro sem sinal √© executada. Se o valor1 for maior que o valor2, o valor int 1 ser√° empilhado para a pilha de operandos. Se o valor1 for igual ao valor2, o valor int 0 ser√° empilhado na pilha de operandos. Se o valor1 for menor que o valor2, o valor int -1 ser√° empilhado na pilha de operandos.
 * Se o novo valor1 for maior que o novo valor2, o valor inteiro 1 √© empilhado na pilha de operandos.
 * Caso contr√°rio, se o novo valor1 for igual ao novo valor2, o valor inteiro 0 ser√° empilhado na pilha de operandos.
 * Caso contr√°rio, se o novo valor1 for menor que o novo valor2, o valor inteiro -1 ser√° empilhado na pilha de operandos.
 * Caso contr√°rio, pelo menos um dos value1 ou value2 novos √© NaN. A instru√ß√£o fcmpl envia o valor int -1 para a pilha de operandos.
 * A compara√ß√£o de ponto flutuante √© realizada de acordo com a IEEE 754. Todos os valores diferentes de NaN s√£o ordenados, com infinito negativo menor que todos os valores finitos e infinito positivo maior que todos os valores finitos. O zero positivo e o zero negativo s√£o considerados iguais.
 * 
 */
void manipulador_fcmpl (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    int resultado = 0;

    if (std::isnan(valor_1->tipo_float) || std::isnan(valor_2->tipo_float))
        resultado = 1;
    else if ((int)valor_1->tipo_float < (int)valor_2->tipo_float)
        resultado = 1;
    else if ((int)valor_1->tipo_float > (int)valor_2->tipo_float)
        resultado = -1;

    std::memcpy(&valor_1->tipo_int, &resultado, sizeof(u4));
    valor_1->tag = TAG_INT;    frame->empilhar(valor_1);
    frame->pc++;
}

// 150 (0x96)
/**
 * @brief Compara dois valores do tipo float
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor1 e o valor2 devem ser do tipo longo. Ambos s√£o removidos da pilha de operandos e uma compara√ß√£o de n√∫mero inteiro sem sinal √© executada. Se o valor1 for maior que o valor2, o valor int 1 ser√° empilhado para a pilha de operandos. Se o valor1 for igual ao valor2, o valor int 0 ser√° empilhado na pilha de operandos. Se o valor1 for menor que o valor2, o valor int -1 ser√° empilhado na pilha de operandos.
 * Se o novo valor1 for maior que o novo valor2, o valor inteiro 1 √© empilhado na pilha de operandos.
 * Caso contr√°rio, se o novo valor1 for igual ao novo valor2, o valor inteiro 0 ser√° empilhado na pilha de operandos.
 * Caso contr√°rio, se o novo valor1 for menor que o novo valor2, o valor inteiro -1 ser√° empilhado na pilha de operandos.
 * Caso contr√°rio, pelo menos um dos value1 ou value2 novos √© NaN. A instru√ß√£o fcmpg envia o valor inteiro 1 para a pilha de operandos.
 * A compara√ß√£o de ponto flutuante √© realizada de acordo com a IEEE 754. Todos os valores diferentes de NaN s√£o ordenados, com infinito negativo menor que todos os valores finitos e infinito positivo maior que todos os valores finitos. O zero positivo e o zero negativo s√£o considerados iguais.
 * 
 */

void manipulador_fcmpg (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    int resultado = 0;

    if (std::isnan(valor_1->tipo_float) || std::isnan(valor_2->tipo_float))
        resultado = 1;
    else if ((float)valor_1->tipo_float < (float)valor_2->tipo_float)
        resultado = 1;
    else if ((float)valor_1->tipo_float > (float)valor_2->tipo_float)
        resultado = -1;

    std::memcpy(&valor_1->tipo_int, &resultado, sizeof(u4));
    valor_1->tag = TAG_INT;    frame->empilhar(valor_1);
    frame->pc++;
}

// 151 (0x97)
/**
 * @brief Compara dois valores do tipo double
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor1 e o valor2 devem ser do tipo double. Os valores s√£o removidos da pilha de operandos e passam pela convers√£o de valores. Uma compara√ß√£o de ponto flutuante √© realizada:
 * Se o novo valor1 for maior que o novo valor2, o valor inteiro 1 √© empilhado na pilha de operandos.
 * Caso contr√°rio, se o valor1 for igual ao valor2', o valor inteiro 0 ser√° empilhado na pilha de operandos.
 * Caso contr√°rio, se o valor1 for menor que o valor2, o valor inteiro -1 ser√° empilhado na pilha de operandos.
 * Caso contr√°rio, pelo menos um dos valor1 ou valor2' √© NaN. A instru√ß√£o dcmpg envia o valor int 1 para a pilha de operandos e a instru√ß√£o dcmpl envia o valor inteiro -1 para a pilha de operandos.
 * A compara√ß√£o de ponto flutuante √© realizada de acordo com a IEEE 754. Todos os valores diferentes de NaN s√£o ordenados, com infinito negativo menor que todos os valores finitos e infinito positivo maior que todos os valores finitos. O zero positivo e o zero negativo s√£o considerados iguais.
 * 
 */
void manipulador_dcmpl (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    int resultado = 0;

    if (std::isnan(valor_1->tipo_double) || std::isnan(valor_2->tipo_double))
        resultado = 1;
    else if ((long)valor_1->tipo_double < (long)valor_2->tipo_double)
        resultado = 1;
    else if ((long)valor_1->tipo_double > (long)valor_2->tipo_double)
        resultado = -1;

    std::memcpy(&valor_1->tipo_int, &resultado, sizeof(u4));
    valor_1->tag = TAG_INT;    frame->empilhar(valor_1);
    frame->pc++;
}

// 152 (0x98)
/**
 * @brief Compara dois valores do tipo double
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor1 e o valor2 devem ser do tipo double. Os valores s√£o removidos da pilha de operandos e passam pela convers√£o de valores. Uma compara√ß√£o de ponto flutuante √© realizada:
 * Se o novo valor1 for maior que o novo valor2, o valor inteiro 1 √© empilhado na pilha de operandos.
 * Caso contr√°rio, se o valor1 for igual ao valor2', o valor inteiro 0 ser√° empilhado na pilha de operandos.
 * Caso contr√°rio, se o valor1 for menor que o valor2, o valor inteiro -1 ser√° empilhado na pilha de operandos.
 * Caso contr√°rio, pelo menos um dos valor1 ou valor2' √© NaN. A instru√ß√£o dcmpg envia o valor int 1 para a pilha de operandos e a instru√ß√£o dcmpl envia o valor inteiro -1 para a pilha de operandos.
 * A compara√ß√£o de ponto flutuante √© realizada de acordo com a IEEE 754. Todos os valores diferentes de NaN s√£o ordenados, com infinito negativo menor que todos os valores finitos e infinito positivo maior que todos os valores finitos. O zero positivo e o zero negativo s√£o considerados iguais.
 * 
 */
void manipulador_dcmpg (Frame *frame){
    Operando *valor_1 = frame->desempilhar();
    Operando *valor_2 = frame->desempilhar();

    int resultado = 0;
    if (std::isnan(valor_1->tipo_double) || std::isnan(valor_2->tipo_double))
        resultado = 1;
    else if (valor_1->tipo_double < valor_2->tipo_double)
        resultado = 1;
    else if (valor_1->tipo_double > valor_2->tipo_double)
        resultado = -1;

    std::memcpy(&valor_1->tipo_int, &resultado, sizeof(u4));
    valor_1->tag = TAG_INT;    frame->empilhar(valor_1);
    frame->pc++;
}

// 153 (0x99)
/**
 * @brief Faz um salto se um valor inteiro comparado com zero for verdadeiro
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor deve ser do tipo inteiro. Ele √© retirado da pilha de operandos e comparado com zero. Todas as compara√ß√µes s√£o feitas com sinal. Os resultados das compara√ß√µes s√£o os seguintes:
 * ifeq ser√° bem-sucedido se, e somente se, valor = 0
 * ifne √© bem-sucedido se e somente se o valor ‚â† 0
 * iflt √© bem-sucedido se e somente se o valor <0
 * ifle √© bem-sucedido se e somente se o valor ‚â§ 0
 * ifle √© bem-sucedido se e somente se o valor ‚â§ 0
 * O ifgt ser√° bem-sucedido se e somente se o valor> 0
 * Se a compara√ß√£o for bem-sucedida, branchbyte1 e branchbyte2 sem sinal s√£o usados para construir um deslocamento com sinal de 16 bits, onde o deslocamento √© calculado para ser (branchbyte1 << 8) | branchbyte2. A execu√ß√£o prossegue nesse deslocamento a partir do endere√ßo do c√≥digo de opera√ß√£o desta instru√ß√£o if <cond>. O endere√ßo de destino deve ser o de um c√≥digo de opera√ß√£o de uma instru√ß√£o dentro do m√©todo que cont√©m esta instru√ß√£o if <cond>.
 * Caso contr√°rio, a execu√ß√£o continuar√° no endere√ßo da instru√ß√£o ap√≥s esta instru√ß√£o <cond>.
 * 
 */
void manipulador_ifeq (Frame *frame){
    Operando *op = frame->desempilhar();
    int16_t deslocamento = 3;

    if ((int)op->tipo_int == 0) {
        deslocamento = get_deslocamento(frame);
    }    frame->pc += deslocamento;
}

// 154 (0x9A)
/**
 * @brief Faz um salto se um valor inteiro comparado com zero for verdadeiro
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor deve ser do tipo inteiro. Ele √© retirado da pilha de operandos e comparado com zero. Todas as compara√ß√µes s√£o feitas com sinal. Os resultados das compara√ß√µes s√£o os seguintes:
 * ifeq ser√° bem-sucedido se, e somente se, valor = 0
 * ifne √© bem-sucedido se e somente se o valor ‚â† 0
 * iflt √© bem-sucedido se e somente se o valor <0
 * ifle √© bem-sucedido se e somente se o valor ‚â§ 0
 * O ifgt ser√° bem-sucedido se e somente se o valor> 0
 * ifge √© bem-sucedido se, e somente se, valor ‚â• 0
 * Se a compara√ß√£o for bem-sucedida, branchbyte1 e branchbyte2 sem sinal s√£o usados para construir um deslocamento com sinal de 16 bits, onde o deslocamento √© calculado para ser (branchbyte1 << 8) | branchbyte2. A execu√ß√£o prossegue nesse deslocamento a partir do endere√ßo do c√≥digo de opera√ß√£o desta instru√ß√£o if <cond>. O endere√ßo de destino deve ser o de um c√≥digo de opera√ß√£o de uma instru√ß√£o dentro do m√©todo que cont√©m esta instru√ß√£o if <cond>.
 * Caso contr√°rio, a execu√ß√£o continuar√° no endere√ßo da instru√ß√£o ap√≥s esta instru√ß√£o <cond>.
 * 
 */
void manipulador_ifne (Frame *frame){
    Operando *op = frame->desempilhar();
    int16_t deslocamento = 3;

    if ((int)op->tipo_int != 0) {
        deslocamento = get_deslocamento(frame);
    }    frame->pc += deslocamento;
}

// 155 (0x9B)
/**
 * @brief Faz um salto se um valor inteiro comparado com zero for verdadeiro
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor deve ser do tipo inteiro. Ele √© retirado da pilha de operandos e comparado com zero. Todas as compara√ß√µes s√£o feitas com sinal. Os resultados das compara√ß√µes s√£o os seguintes:
 * ifeq ser√° bem-sucedido se, e somente se, valor = 0
 * ifne √© bem-sucedido se e somente se o valor ‚â† 0
 * iflt √© bem-sucedido se e somente se o valor <0
 * ifle √© bem-sucedido se e somente se o valor ‚â§ 0
 * O ifgt ser√° bem-sucedido se e somente se o valor> 0
 * ifge √© bem-sucedido se, e somente se, valor ‚â• 0
 * Se a compara√ß√£o for bem-sucedida, branchbyte1 e branchbyte2 sem sinal s√£o usados para construir um deslocamento com sinal de 16 bits, onde o deslocamento √© calculado para ser (branchbyte1 << 8) | branchbyte2. A execu√ß√£o prossegue nesse deslocamento a partir do endere√ßo do c√≥digo de opera√ß√£o desta instru√ß√£o if <cond>. O endere√ßo de destino deve ser o de um c√≥digo de opera√ß√£o de uma instru√ß√£o dentro do m√©todo que cont√©m esta instru√ß√£o if <cond>.
 * Caso contr√°rio, a execu√ß√£o continuar√° no endere√ßo da instru√ß√£o ap√≥s esta instru√ß√£o <cond>.
 * 
 */
void manipulador_iflt (Frame *frame){
    Operando *op = frame->desempilhar();
    int16_t deslocamento = 3;

    if ((int)op->tipo_int < 0) {
        deslocamento = get_deslocamento(frame);
    }    frame->pc += deslocamento;
}

// 156 (0x9C)
/**
 * @brief Faz um salto se um valor inteiro comparado com zero for verdadeiro
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor deve ser do tipo inteiro. Ele √© retirado da pilha de operandos e comparado com zero. Todas as compara√ß√µes s√£o feitas com sinal. Os resultados das compara√ß√µes s√£o os seguintes:
 * ifeq ser√° bem-sucedido se, e somente se, valor = 0
 * ifne √© bem-sucedido se e somente se o valor ‚â† 0
 * iflt √© bem-sucedido se e somente se o valor <0
 * ifle √© bem-sucedido se e somente se o valor ‚â§ 0
 * O ifgt ser√° bem-sucedido se e somente se o valor> 0
 * ifge √© bem-sucedido se, e somente se, valor ‚â• 0
 * Se a compara√ß√£o for bem-sucedida, branchbyte1 e branchbyte2 sem sinal s√£o usados para construir um deslocamento com sinal de 16 bits, onde o deslocamento √© calculado para ser (branchbyte1 << 8) | branchbyte2. A execu√ß√£o prossegue nesse deslocamento a partir do endere√ßo do c√≥digo de opera√ß√£o desta instru√ß√£o if <cond>. O endere√ßo de destino deve ser o de um c√≥digo de opera√ß√£o de uma instru√ß√£o dentro do m√©todo que cont√©m esta instru√ß√£o if <cond>.
 * Caso contr√°rio, a execu√ß√£o continuar√° no endere√ßo da instru√ß√£o ap√≥s esta instru√ß√£o <cond>.
 * 
 */
void manipulador_ifge (Frame *frame){
    Operando *op = frame->desempilhar();
    int16_t deslocamento = 3;

    if ((int)op->tipo_int >= 0) {
        deslocamento = get_deslocamento(frame);
    }    frame->pc += deslocamento;
}

// 157 (0x9D)
// 156 (0x9C)
/**
 * @brief Faz um salto se um valor inteiro comparado com zero for verdadeiro
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor deve ser do tipo inteiro. Ele √© retirado da pilha de operandos e comparado com zero. Todas as compara√ß√µes s√£o feitas com sinal. Os resultados das compara√ß√µes s√£o os seguintes:
 * ifeq ser√° bem-sucedido se, e somente se, valor = 0
 * ifne √© bem-sucedido se e somente se o valor ‚â† 0
 * iflt √© bem-sucedido se e somente se o valor <0
 * ifle √© bem-sucedido se e somente se o valor ‚â§ 0
 * O ifgt ser√° bem-sucedido se e somente se o valor> 0
 * ifge √© bem-sucedido se, e somente se, valor ‚â• 0
 * Se a compara√ß√£o for bem-sucedida, branchbyte1 e branchbyte2 sem sinal s√£o usados para construir um deslocamento com sinal de 16 bits, onde o deslocamento √© calculado para ser (branchbyte1 << 8) | branchbyte2. A execu√ß√£o prossegue nesse deslocamento a partir do endere√ßo do c√≥digo de opera√ß√£o desta instru√ß√£o if <cond>. O endere√ßo de destino deve ser o de um c√≥digo de opera√ß√£o de uma instru√ß√£o dentro do m√©todo que cont√©m esta instru√ß√£o if <cond>.
 * Caso contr√°rio, a execu√ß√£o continuar√° no endere√ßo da instru√ß√£o ap√≥s esta instru√ß√£o <cond>.
 * 
 */
void manipulador_ifgt (Frame *frame){
    Operando *op = frame->desempilhar();
    int16_t deslocamento = 3;

    if ((int)op->tipo_int > 0) {
        deslocamento = get_deslocamento(frame);
    }    frame->pc += deslocamento;
}

// 158 (0x9E)
/**
 * @brief Faz um salto se um valor inteiro comparado com zero for verdadeiro
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor deve ser do tipo inteiro. Ele √© retirado da pilha de operandos e comparado com zero. Todas as compara√ß√µes s√£o feitas com sinal. Os resultados das compara√ß√µes s√£o os seguintes:
 * ifeq ser√° bem-sucedido se, e somente se, valor = 0
 * ifne √© bem-sucedido se e somente se o valor ‚â† 0
 * iflt √© bem-sucedido se e somente se o valor <0
 * ifle √© bem-sucedido se e somente se o valor ‚â§ 0
 * O ifgt ser√° bem-sucedido se e somente se o valor> 0
 * ifge √© bem-sucedido se, e somente se, valor ‚â• 0
 * Se a compara√ß√£o for bem-sucedida, branchbyte1 e branchbyte2 sem sinal s√£o usados para construir um deslocamento com sinal de 16 bits, onde o deslocamento √© calculado para ser (branchbyte1 << 8) | branchbyte2. A execu√ß√£o prossegue nesse deslocamento a partir do endere√ßo do c√≥digo de opera√ß√£o desta instru√ß√£o if <cond>. O endere√ßo de destino deve ser o de um c√≥digo de opera√ß√£o de uma instru√ß√£o dentro do m√©todo que cont√©m esta instru√ß√£o if <cond>.
 * Caso contr√°rio, a execu√ß√£o continuar√° no endere√ßo da instru√ß√£o ap√≥s esta instru√ß√£o <cond>.
 * 
 */
void manipulador_ifle (Frame *frame){
    Operando *op = frame->desempilhar();
    int16_t deslocamento = 3;

    if ((int)op->tipo_int <= 0) {
        deslocamento = get_deslocamento(frame);
    }

    exibir_se_verboso("\t" + std::to_string((int)op->tipo_int) + " <= 0?");
    exibir_se_verboso("\tVai pular para: " + std::to_string(frame->pc + deslocamento));    frame->pc += deslocamento;
}

// 159 (0x9F)
/**
 * @brief Faz um salto se a compara√ß√£o de dois inteiros for verdadeiro
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor1 e o valor2 devem ser do tipo inteiro. Ambos s√£o retirados da pilha de operandos e comparados. Todas as compara√ß√µes s√£o com sinal. Os resultados da compara√ß√£o s√£o os seguintes:
 * if_icmpeq ser√° bem-sucedido se e somente se value1 = value2
 * if_icmpne √© bem-sucedido se e somente se value1 ‚â† value2
 * if_icmplt √© bem-sucedido se e somente se value1 < value2
 * if_icmple √© bem-sucedido se e somente se value1 ‚â§ value2
 * if_icmpgt √© bem-sucedido se e somente se value1 > value2
 * if_icmpge √© bem-sucedido se e somente se value1 ‚â• value2
 * Se a compara√ß√£o for bem-sucedida, branchbyte1 e branchbyte2 sem sinal s√£o usados ‚Äã‚Äãpara construir um deslocamento com sinal de 16 bits, onde o deslocamento √© calculado para ser 
 * (branchbyte1 << 8) | branchbyte2. A execu√ß√£o prossegue nesse deslocamento a partir do endere√ßo do c√≥digo de opera√ß√£o desta instru√ß√£o if_icmp <cond>. O endere√ßo de destino deve 
 * ser o de um c√≥digo de opera√ß√£o de uma instru√ß√£o dentro do m√©todo que cont√©m esta instru√ß√£o if_icmp <cond>.
 * 
 */
void manipulador_if_icmpeq (Frame *frame){
    Operando *op_1 = frame->desempilhar();
    Operando *op_2 = frame->desempilhar();
    int16_t deslocamento = 3;
    int i2 = (int) op_2->tipo_int,
        i1 = (int) op_1->tipo_int;

    if (i2 == i1) {
        deslocamento = get_deslocamento(frame);
    }

    exibir_se_verboso("\tVerificando se " + std::to_string(i2) + " == " + std::to_string(i1));
    exibir_se_verboso("\tCom deslocamento de " + std::to_string(deslocamento)
        + " vai para " + std::to_string(frame->pc + deslocamento));

    frame->pc += deslocamento;
}

// 160 (0xA0)
/**
 * @brief Faz um salto se a compara√ß√£o de dois inteiros for verdadeiro
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor1 e o valor2 devem ser do tipo inteiro. Ambos s√£o retirados da pilha de operandos e comparados. Todas as compara√ß√µes s√£o com sinal. Os resultados da compara√ß√£o s√£o os seguintes:
 * if_icmpeq ser√° bem-sucedido se e somente se value1 = value2
 * if_icmpne √© bem-sucedido se e somente se value1 ‚â† value2
 * if_icmplt √© bem-sucedido se e somente se value1 < value2
 * if_icmple √© bem-sucedido se e somente se value1 ‚â§ value2
 * if_icmpgt √© bem-sucedido se e somente se value1 > value2
 * if_icmpge √© bem-sucedido se e somente se value1 ‚â• value2
 * Se a compara√ß√£o for bem-sucedida, branchbyte1 e branchbyte2 sem sinal s√£o usados ‚Äã‚Äãpara construir um deslocamento com sinal de 16 bits, onde o deslocamento √© calculado para ser 
 * (branchbyte1 << 8) | branchbyte2. A execu√ß√£o prossegue nesse deslocamento a partir do endere√ßo do c√≥digo de opera√ß√£o desta instru√ß√£o if_icmp <cond>. O endere√ßo de destino deve 
 * ser o de um c√≥digo de opera√ß√£o de uma instru√ß√£o dentro do m√©todo que cont√©m esta instru√ß√£o if_icmp <cond>.
 * 
 */
void manipulador_if_icmpne (Frame *frame){
    Operando *op_1 = frame->desempilhar();
    Operando *op_2 = frame->desempilhar();

    int16_t deslocamento = 3;
    int i2 = (int) op_2->tipo_int,
        i1 = (int) op_1->tipo_int;

    if (i2 != i1) {
        deslocamento = get_deslocamento(frame);
    }

    exibir_se_verboso("\tVerificando se " + std::to_string(i2) + " != " + std::to_string(i1));
    exibir_se_verboso("\tCom deslocamento de " + std::to_string(deslocamento)
        + " vai para " + std::to_string(frame->pc + deslocamento));

    frame->pc += deslocamento;
}

// 161 (0xA1)
/**
 * @brief Faz um salto se a compara√ß√£o de dois inteiros for verdadeiro
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor1 e o valor2 devem ser do tipo inteiro. Ambos s√£o retirados da pilha de operandos e comparados. Todas as compara√ß√µes s√£o com sinal. Os resultados da compara√ß√£o s√£o os seguintes:
 * if_icmpeq ser√° bem-sucedido se e somente se value1 = value2
 * if_icmpne √© bem-sucedido se e somente se value1 ‚â† value2
 * if_icmplt √© bem-sucedido se e somente se value1 < value2
 * if_icmple √© bem-sucedido se e somente se value1 ‚â§ value2
 * if_icmpgt √© bem-sucedido se e somente se value1 > value2
 * if_icmpge √© bem-sucedido se e somente se value1 ‚â• value2
 * Se a compara√ß√£o for bem-sucedida, branchbyte1 e branchbyte2 sem sinal s√£o usados ‚Äã‚Äãpara construir um deslocamento com sinal de 16 bits, onde o deslocamento √© calculado para ser 
 * (branchbyte1 << 8) | branchbyte2. A execu√ß√£o prossegue nesse deslocamento a partir do endere√ßo do c√≥digo de opera√ß√£o desta instru√ß√£o if_icmp <cond>. O endere√ßo de destino deve 
 * ser o de um c√≥digo de opera√ß√£o de uma instru√ß√£o dentro do m√©todo que cont√©m esta instru√ß√£o if_icmp <cond>.
 * 
 */
void manipulador_if_icmplt (Frame *frame){
    Operando *op_1 = frame->desempilhar();
    Operando *op_2 = frame->desempilhar();

    int16_t deslocamento = 3;
    int i2 = (int) op_2->tipo_int,
        i1 = (int)op_1->tipo_int;

    if (i2 < i1) {
        deslocamento = get_deslocamento(frame);
    }

    exibir_se_verboso("\tVerificando se " + std::to_string(i2) + " < " + std::to_string(i1));
    exibir_se_verboso("\tCom deslocamento de " + std::to_string(deslocamento)
        + " vai para " + std::to_string(frame->pc + deslocamento));

    frame->pc += deslocamento;
}

// 162 (0xA2)
/**
 * @brief Faz um salto se a compara√ß√£o de dois inteiros for verdadeiro
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor1 e o valor2 devem ser do tipo inteiro. Ambos s√£o retirados da pilha de operandos e comparados. Todas as compara√ß√µes s√£o com sinal. Os resultados da compara√ß√£o s√£o os seguintes:
 * if_icmpeq ser√° bem-sucedido se e somente se value1 = value2
 * if_icmpne √© bem-sucedido se e somente se value1 ‚â† value2
 * if_icmplt √© bem-sucedido se e somente se value1 < value2
 * if_icmple √© bem-sucedido se e somente se value1 ‚â§ value2
 * if_icmpgt √© bem-sucedido se e somente se value1 > value2
 * if_icmpge √© bem-sucedido se e somente se value1 ‚â• value2
 * Se a compara√ß√£o for bem-sucedida, branchbyte1 e branchbyte2 sem sinal s√£o usados ‚Äã‚Äãpara construir um deslocamento com sinal de 16 bits, onde o deslocamento √© calculado para ser 
 * (branchbyte1 << 8) | branchbyte2. A execu√ß√£o prossegue nesse deslocamento a partir do endere√ßo do c√≥digo de opera√ß√£o desta instru√ß√£o if_icmp <cond>. O endere√ßo de destino deve 
 * ser o de um c√≥digo de opera√ß√£o de uma instru√ß√£o dentro do m√©todo que cont√©m esta instru√ß√£o if_icmp <cond>.
 * 
 */
void manipulador_if_icmpge (Frame *frame){
    Operando *op_1 = frame->desempilhar();
    Operando *op_2 = frame->desempilhar();

    int16_t deslocamento = 3;
    int i2 = (int) op_2->tipo_int,
        i1 = (int)op_1->tipo_int;

    if (i2 >= i1) {
        deslocamento = get_deslocamento(frame);
    }

    exibir_se_verboso("\tVerificando se " + std::to_string(i2) + " >= " + std::to_string(i1));
    exibir_se_verboso("\tCom deslocamento de " + std::to_string(deslocamento)
        + " vai para " + std::to_string(frame->pc + deslocamento));

    frame->pc += deslocamento;
}

// 163 (0xA3)
/**
 * @brief Faz um salto se a compara√ß√£o de dois inteiros for verdadeiro
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor1 e o valor2 devem ser do tipo inteiro. Ambos s√£o retirados da pilha de operandos e comparados. Todas as compara√ß√µes s√£o com sinal. Os resultados da compara√ß√£o s√£o os seguintes:
 * if_icmpeq ser√° bem-sucedido se e somente se value1 = value2
 * if_icmpne √© bem-sucedido se e somente se value1 ‚â† value2
 * if_icmplt √© bem-sucedido se e somente se value1 < value2
 * if_icmple √© bem-sucedido se e somente se value1 ‚â§ value2
 * if_icmpgt √© bem-sucedido se e somente se value1 > value2
 * if_icmpge √© bem-sucedido se e somente se value1 ‚â• value2
 * Se a compara√ß√£o for bem-sucedida, branchbyte1 e branchbyte2 sem sinal s√£o usados ‚Äã‚Äãpara construir um deslocamento com sinal de 16 bits, onde o deslocamento √© calculado para ser 
 * (branchbyte1 << 8) | branchbyte2. A execu√ß√£o prossegue nesse deslocamento a partir do endere√ßo do c√≥digo de opera√ß√£o desta instru√ß√£o if_icmp <cond>. O endere√ßo de destino deve 
 * ser o de um c√≥digo de opera√ß√£o de uma instru√ß√£o dentro do m√©todo que cont√©m esta instru√ß√£o if_icmp <cond>.
 * 
 */
void manipulador_if_icmpgt (Frame *frame){
    Operando *op_1 = frame->desempilhar();
    Operando *op_2 = frame->desempilhar();

    int16_t deslocamento = 3;
    int i2 = (int) op_2->tipo_int,
        i1 = (int)op_1->tipo_int;

    if (i2 > i1) {
        deslocamento = get_deslocamento(frame);
    }

    exibir_se_verboso("\tVerificando se " + std::to_string(i2) + " > " + std::to_string(i1));
    exibir_se_verboso("\tCom deslocamento de " + std::to_string(deslocamento)
        + " vai para " + std::to_string(frame->pc + deslocamento));

    frame->pc += deslocamento;
}

// 164 (0xA4)
/**
 * @brief Faz um salto se a compara√ß√£o de dois inteiros for verdadeiro
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor1 e o valor2 devem ser do tipo inteiro. Ambos s√£o retirados da pilha de operandos e comparados. Todas as compara√ß√µes s√£o com sinal. Os resultados da compara√ß√£o s√£o os seguintes:
 * if_icmpeq ser√° bem-sucedido se e somente se value1 = value2
 * if_icmpne √© bem-sucedido se e somente se value1 ‚â† value2
 * if_icmplt √© bem-sucedido se e somente se value1 < value2
 * if_icmple √© bem-sucedido se e somente se value1 ‚â§ value2
 * if_icmpgt √© bem-sucedido se e somente se value1 > value2
 * if_icmpge √© bem-sucedido se e somente se value1 ‚â• value2
 * Se a compara√ß√£o for bem-sucedida, branchbyte1 e branchbyte2 sem sinal s√£o usados ‚Äã‚Äãpara construir um deslocamento com sinal de 16 bits, onde o deslocamento √© calculado para ser 
 * (branchbyte1 << 8) | branchbyte2. A execu√ß√£o prossegue nesse deslocamento a partir do endere√ßo do c√≥digo de opera√ß√£o desta instru√ß√£o if_icmp <cond>. O endere√ßo de destino deve 
 * ser o de um c√≥digo de opera√ß√£o de uma instru√ß√£o dentro do m√©todo que cont√©m esta instru√ß√£o if_icmp <cond>.
 * 
 */
void manipulador_if_icmple (Frame *frame){
    Operando *op_1 = frame->desempilhar();
    Operando *op_2 = frame->desempilhar();

    int16_t deslocamento = 3;
    int i2 = (int) op_2->tipo_int,
        i1 = (int)op_1->tipo_int;

    if (i2 <= i1) {
        deslocamento = get_deslocamento(frame);
    }

    exibir_se_verboso("\tVerificando se " + std::to_string(i2) + " <= " + std::to_string(i1));
    exibir_se_verboso("\tCom deslocamento de " + std::to_string(deslocamento)
        + " vai para " + std::to_string(frame->pc + deslocamento));

    frame->pc += deslocamento;
}

// 165 (0xA5)
/**
 * @brief Faz um salto se a compara√ß√£o entre refer√™ncias for verdadeira
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor1 e o valor2 devem ser de refer√™ncia do tipo. Ambos s√£o retirados da pilha de operandos e comparados. Os resultados da compara√ß√£o s√£o os seguintes:
 * if_acmpeq ser√° bem-sucedido se e somente se value1 = value2
 * if_acmpne √© bem-sucedido se e somente se value1 ‚â† value2
 * Se a compara√ß√£o for bem-sucedida, branchbyte1 e branchbyte2 sem sinal s√£o usados para construir um deslocamento de 16 bits com sinal, onde o deslocamento √© calculado para ser (branchbyte1 << 8) | branchbyte2. A execu√ß√£o prossegue nesse deslocamento a partir do endere√ßo do c√≥digo de opera√ß√£o desta instru√ß√£o if_acmp <cond>. O endere√ßo de destino deve ser o c√≥digo de opera√ß√£o de uma instru√ß√£o dentro do m√©todo que cont√©m esta instru√ß√£o if_acmp <cond>.
 * Caso contr√°rio, se a compara√ß√£o falhar, a execu√ß√£o continuar√° no endere√ßo da instru√ß√£o ap√≥s esta instru√ß√£o if_acmp <cond>.
 * 
 */
void manipulador_if_acmpeq (Frame *frame){
    Operando *valor_2 = frame->desempilhar();
    Operando *valor_1 = frame->desempilhar();

    int16_t deslocamento = 3;

    if ((valor_2->tag == valor_1->tag) && (((u4) valor_2->tipo_byte) == ((u4) valor_1->tipo_byte))){
        deslocamento = get_deslocamento(frame);
    }

    frame->pc += deslocamento;
}

// 166 (0xA6)
/**
 * @brief Faz um salto se a compara√ß√£o entre refer√™ncias for verdadeira
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * O valor1 e o valor2 devem ser de refer√™ncia do tipo. Ambos s√£o retirados da pilha de operandos e comparados. Os resultados da compara√ß√£o s√£o os seguintes:
 * if_acmpeq ser√° bem-sucedido se e somente se value1 = value2
 * if_acmpne √© bem-sucedido se e somente se value1 ‚â† value2
 * Se a compara√ß√£o for bem-sucedida, branchbyte1 e branchbyte2 sem sinal s√£o usados para construir um deslocamento de 16 bits com sinal, onde o deslocamento √© calculado para ser (branchbyte1 << 8) | branchbyte2. A execu√ß√£o prossegue nesse deslocamento a partir do endere√ßo do c√≥digo de opera√ß√£o desta instru√ß√£o if_acmp <cond>. O endere√ßo de destino deve ser o c√≥digo de opera√ß√£o de uma instru√ß√£o dentro do m√©todo que cont√©m esta instru√ß√£o if_acmp <cond>.
 * Caso contr√°rio, se a compara√ß√£o falhar, a execu√ß√£o continuar√° no endere√ßo da instru√ß√£o ap√≥s esta instru√ß√£o if_acmp <cond>.
 * 
 */
void manipulador_if_acmpne (Frame *frame){
    Operando *valor_2 = frame->desempilhar();
    Operando *valor_1 = frame->desempilhar();

    int16_t deslocamento = 3;

    if ((valor_2->tag != valor_1->tag)
            || (((u4) valor_2->tipo_byte) != ((u4) valor_1->tipo_byte))){
        deslocamento = get_deslocamento(frame);
    }

    frame->pc += deslocamento;
}

// 167 (0xA7)
/**
 * @brief Fun√ß√£o para sempre fazer branch quando o lida
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos
 * 
 * Os bytes sem sinal branchbyte1 e branchbyte2 s√£o usados para construir um branchoffset de 16 bits com sinal, em que branchoffset √© (branchbyte1 << 8) | branchbyte2.
 * A execu√ß√£o prossegue nesse deslocamento a partir do endere√ßo do c√≥digo de opera√ß√£o desta instru√ß√£o goto.
 * O endere√ßo de destino deve ser o de um c√≥digo de opera√ß√£o de uma instru√ß√£o dentro do m√©todo que cont√©m essa instru√ß√£o goto.
 * 
 */
void manipulador_goto (Frame *frame){
    int16_t deslocamento = get_deslocamento(frame);

    exibir_se_verboso("\tCom deslocamento de " + std::to_string(deslocamento)
        + " vai para " + std::to_string(frame->pc + deslocamento));

    frame->pc += deslocamento;
}

// 168 (0xA8)
/**
 * @brief jump para subrotina
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos,
 * 
 * O endere√ßo do c√≥digo de opera√ß√£o da instru√ß√£o imediatamente ap√≥s esta instru√ß√£o jsr √© inserido na pilha de operandos como um valor do tipo returnAddress. 
 * O branchbyte1 e branchbyte2 sem sinal s√£o usados para construir um deslocamento com sinal de 16 bits, onde o deslocamento √© (branchbyte1 << 8) | branchbyte2. 
 * A execu√ß√£o prossegue nesse deslocamento a partir do endere√ßo desta instru√ß√£o jsr. O endere√ßo de destino deve ser o de um c√≥digo de opera√ß√£o de uma instru√ß√£o dentro do m√©todo que cont√©m esta instru√ß√£o jsr.
 */
void manipulador_jsr (Frame *frame){
    Operando *op = new Operando();
    op->tipo_byte = frame->pc;

    frame->empilhar(op);

    frame->pc += get_deslocamento(frame);
}

// 169 (0xA9)
/**
 * @brief Retorno da subrotina
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos. 
 * 
 * O √≠ndice √© um byte sem sinal entre 0 e 255, inclusivo. A vari√°vel local no √≠ndice no frame atual deve conter um valor do tipo returnAddress. O conte√∫do da vari√°vel local √© gravado no registro pc da Java Virtual Machine e a execu√ß√£o continua l√°.
 * 
 */
void manipulador_ret (Frame *frame){
    u1 indice = frame->get_prox_byte();
    Operando *endereco = frame->var_locais.at(indice);

    if (endereco->tag != TAG_END){
        std::cout << "A vari√°vel local [" << (int) indice << "] n√£o √© " << get_tag(TAG_END) << std::endl;
        return;
    }

    frame->pc = endereco->tipo_int;
}

// 170 (0xAA)
/**
 * @brief Acessa a tabela de saltos por √≠ndice e salto
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos. 
 * 
 * Um interruptor de tabela √© uma instru√ß√£o de comprimento vari√°vel.
 * Imediatamente ap√≥s o c√≥digo de opera√ß√£o do comutador de tabelas, entre zero e tr√™s bytes devem atuar como preenchimento, de modo que o byte1 padr√£o comece em um endere√ßo com m√∫ltiplos de quatro bytes desde o in√≠cio do m√©todo atual (o c√≥digo de opera√ß√£o de sua primeira instru√ß√£o).
 * Imediatamente ap√≥s o preenchimento, os bytes constituem tr√™s valores assinados de 32 bits: padr√£o, baixo e alto.
 * A seguir, s√£o apresentados os bytes que constituem uma s√©rie de compensa√ß√µes alta - baixa + 1 assinadas de 32 bits.
 * O valor baixo deve ser menor ou igual a alto.
 * As compensa√ß√µes alta e baixa + 1 assinadas de 32 bits s√£o tratadas como uma tabela de salto baseada em 0. 
 * Cada um desses valores de 32 bits assinados √© constru√≠do como (byte1 << 24) | (byte2 << 16) | (byte3 << 8) | byte4.
 * O √≠ndice deve ser do tipo inteiro e √© exibido na pilha de operandos.
 * Se o √≠ndice for menor que baixo ou se for maior que alto, um endere√ßo de destino ser√° calculado adicionando padr√£o ao endere√ßo do c√≥digo de opera√ß√£o desta instru√ß√£o de comuta√ß√£o de tabela.
 * Caso contr√°rio, o deslocamento no √≠ndice de posi√ß√£o - baixo da tabela de salto √© extra√≠do.
 * O endere√ßo de destino √© calculado adicionando esse deslocamento ao endere√ßo do c√≥digo de opera√ß√£o desta instru√ß√£o de comuta√ß√£o de tabela.
 * A execu√ß√£o continua no endere√ßo de destino.
 * O endere√ßo de destino que pode ser calculado a partir de cada deslocamento da tabela de salto, bem como o que pode ser calculado a partir do padr√£o, deve ser o endere√ßo de um c√≥digo de opera√ß√£o de uma instru√ß√£o dentro do m√©todo que cont√©m esta instru√ß√£o de comuta√ß√£o de tabela.
 * 
 */
void manipulador_tableswitch (Frame *frame){
    frame->pc += bytecodes[170].bytes + 1;
}

// 171 (0xAB)
/**
 * @brief Acesse a tabela de salto por combina√ß√£o de teclas e salto
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos. 
 * 
 * Um lookupswitch √© uma instru√ß√£o de comprimento vari√°vel.
 * Imediatamente ap√≥s o opcode da pesquisa, entre zero e tr√™s bytes deve atuar como preenchimento, de modo que o byte1 padr√£o comece em um endere√ßo m√∫ltiplo de quatro bytes desde o in√≠cio do m√©todo atual (o opcode de sua primeira instru√ß√£o).
 * Imediatamente ap√≥s o preenchimento, siga uma s√©rie de valores de 32 bits assinados: padr√£o, npairs e depois emparelha pares de valores de 32 bits assinados.
 * Os n pares devem ser maiores ou iguais a 0.
 * Cada um dos pares n pares consiste em uma correspond√™ncia int e um deslocamento assinado de 32 bits.
 * Cada um desses valores de 32 bits com sinal √© constru√≠do a partir de quatro bytes n√£o assinados como (byte1 << 24) | (byte2 << 16) | (byte3 << 8) | byte4
 * Os pares de deslocamento de correspond√™ncia de tabela da instru√ß√£o lookupswitch devem ser classificados em ordem num√©rica crescente por correspond√™ncia.
 * A chave deve ser do tipo inteiro e √© exibida na pilha de operandos.
 * A chave √© comparada com os valores correspondentes. Se for igual a um deles, um endere√ßo de destino ser√° calculado adicionando o deslocamento correspondente ao endere√ßo do c√≥digo de opera√ß√£o desta instru√ß√£o da chave de pesquisa. Se a chave n√£o corresponder a nenhum dos valores correspondentes, o endere√ßo de destino ser√° calculado adicionando o padr√£o ao endere√ßo do c√≥digo de opera√ß√£o desta instru√ß√£o de pesquisa. A execu√ß√£o continua no endere√ßo de destino.
 * O endere√ßo de destino que pode ser calculado a partir do deslocamento de cada par de deslocamento de correspond√™ncia, bem como o calculado a partir do padr√£o, deve ser o endere√ßo de um c√≥digo de opera√ß√£o de uma instru√ß√£o no m√©todo que cont√©m essa instru√ß√£o de pesquisa.
 *  
 */
void manipulador_lookupswitch (Frame *frame){
    frame->pc += bytecodes[171].bytes + 1;
}

// 172 (0xAC)
/**
 * @brief Retorna inteiro do m√©todo
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos. 
 * 
 * O m√©todo atual deve ter o tipo de retorno booleano, byte, short, char ou inteiro. 
 * O valor deve ser do tipo int.
 * Se o m√©todo atual for um m√©todo sincronizado, o monitor inserido ou reinserido na invoca√ß√£o do m√©todo ser√° atualizado e possivelmente encerrado como se fosse pela execu√ß√£o de uma instru√ß√£o de monitorexit no encadeamento atual. 
 * Se nenhuma exce√ß√£o for lan√ßada, o valor ser√° exibido na pilha de operandos do frame atual e empurrado para a pilha de operandos do quadro do invocador.
 * Quaisquer outros valores na pilha de operandos do m√©todo atual s√£o descartados.
 * O int√©rprete retorna o controle ao invocador do m√©todo, restabelecendo o frame do invocador.
 * 
 */
void manipulador_ireturn (Frame *frame){
    manipulador_xreturn(frame, TAG_INT);
}

// 173 (0xAD)
/**
 * @brief Retorna longo do m√©todo
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos. 
 * 
 * O valor deve ser do tipo longo.
 * Se o m√©todo atual for um m√©todo sincronizado, o monitor inserido ou reinserido na invoca√ß√£o do m√©todo ser√° atualizado e possivelmente encerrado como se fosse pela execu√ß√£o de uma instru√ß√£o de monitorexit no encadeamento atual.
 * Se nenhuma exce√ß√£o for lan√ßada, o valor ser√° exibido na pilha de operandos do frame atual e empurrado para a pilha de operandos do quadro do invocador.
 * Quaisquer outros valores na pilha de operandos do m√©todo atual s√£o descartados.
 * O int√©rprete retorna o controle ao invocador do m√©todo, restabelecendo o frame do invocador.
 * 
 */
void manipulador_lreturn (Frame *frame){
    manipulador_xreturn(frame, TAG_LNG);
}

// 174 (0xAE)
/**
 * @brief Retorna flutuante do m√©todo
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos. 
 * 
 * O valor deve ser do tipo flutuante.
 * Se o m√©todo atual for um m√©todo sincronizado, o monitor inserido ou reinserido na invoca√ß√£o do m√©todo ser√° atualizado e possivelmente encerrado como se fosse pela execu√ß√£o de uma instru√ß√£o de monitorexit no encadeamento atual.
 * Se nenhuma exce√ß√£o for lan√ßada, o valor ser√° exibido na pilha de operandos do frame atual e empurrado para a pilha de operandos do quadro do invocador.
 * Quaisquer outros valores na pilha de operandos do m√©todo atual s√£o descartados.
 * O int√©rprete retorna o controle ao invocador do m√©todo, restabelecendo o frame do invocador.
 * 
 */
void manipulador_freturn (Frame *frame){
    manipulador_xreturn(frame, TAG_FLT);
}

// 175 (0xAF)
/**
 * @brief Retorna double do m√©todo
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos. 
 * 
 * O valor deve ser do tipo double.
 * Se o m√©todo atual for um m√©todo sincronizado, o monitor inserido ou reinserido na invoca√ß√£o do m√©todo ser√° atualizado e possivelmente encerrado como se fosse pela execu√ß√£o de uma instru√ß√£o de monitorexit no encadeamento atual.
 * Se nenhuma exce√ß√£o for lan√ßada, o valor ser√° exibido na pilha de operandos do frame atual e empurrado para a pilha de operandos do quadro do invocador.
 * Quaisquer outros valores na pilha de operandos do m√©todo atual s√£o descartados.
 * O int√©rprete retorna o controle ao invocador do m√©todo, restabelecendo o frame do invocador.
 * 
 */
void manipulador_dreturn (Frame *frame){
    manipulador_xreturn(frame, TAG_DBL);
}

// 176 (0xB0)
/**
 * @brief Retorna refer√™ncia do m√©todo
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos. 
 * 
 * O objectref deve ser de refer√™ncia de tipo e deve se referir a um objeto de um tipo compat√≠vel com atribui√ß√£o com o tipo representado pelo descritor de retorno do m√©todo atual.
 * Se o m√©todo atual for um m√©todo sincronizado, o monitor inserido ou reinserido na invoca√ß√£o do m√©todo ser√° atualizado e possivelmente encerrado como se fosse pela execu√ß√£o de uma instru√ß√£o de monitorexit no encadeamento atual.
 * Se nenhuma exce√ß√£o for lan√ßada, o valor ser√° exibido na pilha de operandos do frame atual e empurrado para a pilha de operandos do quadro do invocador.
 * Quaisquer outros valores na pilha de operandos do m√©todo atual s√£o descartados.
 * O int√©rprete retorna o controle ao invocador do m√©todo, restabelecendo o frame do invocador.
 * 
 */
void manipulador_areturn (Frame *frame){
    manipulador_xreturn(frame, TAG_REF);
}

// 177 (0xB1)
/**
 * @brief Retorna void do m√©todo
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos. 
 * 
 * O m√©todo atual deve ter o tipo de retorno nulo.
 * Se o m√©todo atual for um m√©todo sincronizado, o monitor inserido ou reinserido na invoca√ß√£o do m√©todo ser√° atualizado e possivelmente encerrado como se fosse pela execu√ß√£o de uma instru√ß√£o de monitorexit no encadeamento atual.
 * Se nenhuma exce√ß√£o for lan√ßada, o valor ser√° exibido na pilha de operandos do frame atual e empurrado para a pilha de operandos do quadro do invocador.
 * Quaisquer outros valores na pilha de operandos do m√©todo atual s√£o descartados.
 * O int√©rprete retorna o controle ao invocador do m√©todo, restabelecendo o frame do invocador.
 * 
 */
void manipulador_return (Frame *frame){
    manipulador_xreturn(frame, TAG_VAZ);
}

// 178 (0xB2)
/**
 * @brief Obter campo est√°tico da classe
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos. 
 * 
 * O indexbyte1 e indexbyte2 sem sinal s√£o usados para construir um √≠ndice no pool constant de tempo de execu√ß√£o da classe atual, em que o valor do √≠ndice √© (indexbyte1 << 8) | indexbyte2.
 * O item de constant pool em tempo de execu√ß√£o nesse √≠ndice deve ser uma refer√™ncia simb√≥lica a um campo, que fornece o nome e o descritor do campo, bem como uma refer√™ncia simb√≥lica √† classe ou interface na qual o campo deve ser encontrado. 
 * O campo referenciado √© resolvido.
 * Na resolu√ß√£o bem-sucedida do campo, a classe ou interface que declarou o campo resolvido √© inicializada se essa classe ou interface ainda n√£o tiver sido inicializada.
 * O valor do campo de classe ou interface √© buscado e enviado para a pilha de operandos.
 * 
 */
void manipulador_getstatic (Frame *frame){
    u1 byte_1 = frame->get_prox_byte();
    u1 byte_2 = frame->get_prox_byte();
    u2 indice = (byte_1 << 8) | byte_2;

    InterCPDado *c_dados = frame->buscar_simbolo(indice);

    if (!c_dados){
        std::cout << "N√£o existe dados no √≠ndice: " << indice << std::endl;
        return;
    }

    if (c_dados->tag != TAG_REF_CMP){
        std::cout << "N√£o √© poss√≠vel acessar um campo est√°tico com a refer√™ncia errada" << std::endl;
        std::cout << "\tDeveria ser " << get_tag(TAG_REF_CMP) << " mas √© " << get_tag(c_dados->tag) << std::endl;
        return;
    }

    std::string nome_classe = (dynamic_cast<InfoRefCampo*>(c_dados))->get_nome_classe();

    if (!nome_classe.compare("java/lang/System")){
        exibir_se_verboso("\tSendo 'java/lang/System', n√£o precisa");
        frame->pc++;
        return;
    }

    exibir_se_verboso("\tInd: " + std::to_string((int) indice));

    frame->a_empilhar = c_dados;
    frame->pc++;
}

// 179 (0xB3)
/**
 * @brief Define campo est√°tico da classe
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos. 
 * 
 * O indexbyte1 e indexbyte2 sem sinal s√£o usados ‚Äã‚Äãpara construir um √≠ndice no constant pool de tempo de execu√ß√£o da classe atual, em que o valor do √≠ndice √© (indexbyte1 << 8) | indexbyte2. 
 * O item de constant pool em tempo de execu√ß√£o nesse √≠ndice deve ser uma refer√™ncia simb√≥lica a um campo, que fornece o nome e o descritor do campo, bem como uma refer√™ncia simb√≥lica √† classe ou interface na qual o campo deve ser encontrado. 
 * O campo referenciado √© resolvido.
 * Na resolu√ß√£o bem-sucedida do campo, a classe ou interface que declarou o campo resolvido √© inicializada se essa classe ou interface ainda n√£o tiver sido inicializada.
 * O valor do campo de classe ou interface √© buscado e enviado para a pilha de operandos.
 * O tipo de valor armazenado por uma instru√ß√£o putstatic deve ser compat√≠vel com o descritor do campo referenciado.
 * Se o tipo de descritor de campo for booleano, byte, char, short ou int, o valor dever√° ser um int. Se o tipo de descritor de campo for flutuante, longo ou duplo, o valor dever√° ser flutuante, longo ou duplo, respectivamente. Se o tipo de descritor de campo for um tipo de refer√™ncia, o valor dever√° ser de um tipo compat√≠vel com a atribui√ß√£o com o tipo de descritor de campo.
 * Se o campo for final, ele deve ser declarado na classe atual e a instru√ß√£o deve ocorrer no m√©todo <clinit> da classe atual.
 * O valor √© retirado da pilha de operandos e passa pela convers√£o do conjunto de valores. O campo da classe est√° definido como valor.
 * 
 */
void manipulador_putstatic (Frame *frame){
    u1 byte_1 = frame->get_prox_byte();
    u1 byte_2 = frame->get_prox_byte();

    u2 indice = (byte_1 << 8) | byte_2;

    InterCPDado *c_dados = frame->buscar_simbolo(indice);

    if (c_dados->tag != TAG_REF_CMP){
        std::cout << "N√£o √© poss√≠vel acessar um campo com a refer√™ncia errada" << std::endl;
        std::cout << "\t" << get_tag(c_dados->tag) << " n√£o √© " << get_tag(TAG_REF_CMP) << std::endl;
        return;
    }

    std::string nome_classe = (dynamic_cast<InfoRefCampo*>(c_dados))->get_nome_classe();

    if (!nome_classe.compare("java/lang/System")){
        // std::cout << "\tN√£o precisa" << std::endl;
        frame->pc++;
        return;
    }

    frame->a_empilhar = c_dados;
    frame->retorno = frame->desempilhar();
    frame->pc++;
}

// 180 (0xB4)
/**
 * @brief Buscar campo do objeto
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos. 
 * 
 * O objectref, que deve ser do tipo refer√™ncia, √© exibido na pilha de operandos.
 * O indexbyte1 e indexbyte2 sem sinal s√£o usados para construir um √≠ndice no constant pool de tempo de execu√ß√£o da classe atual, em que o valor do √≠ndice √© (indexbyte1 << 8) | indexbyte2. O item de constant pool em tempo de execu√ß√£o nesse √≠ndice deve ser uma refer√™ncia simb√≥lica a um campo, que fornece o nome e o descritor do campo, bem como uma refer√™ncia simb√≥lica √† classe na qual o campo deve ser encontrado. 
 * O campo referenciado √© resolvido. O valor do campo referenciado no objectref √© buscado e enviado para a pilha de operandos.
 * O tipo de objectref n√£o deve ser um tipo de matriz. Se o campo estiver protegido e for membro de uma superclasse da classe atual, e o campo n√£o for declarado no mesmo pacote de tempo de execu√ß√£o da classe atual, a classe de objectref deve ser a classe atual ou uma subclasse da classe atual.
 * 
 */
void manipulador_getfield (Frame *frame){
    u1 byte_1 = frame->get_prox_byte();
    u1 byte_2 = frame->get_prox_byte();
    u2 indice = (byte_1 << 8) | byte_2;

    InterCPDado *c_dados = frame->buscar_simbolo(indice);
    if (!c_dados){
        std::cout << "N√£o existe dados no √≠ndice: " << (int) indice << std::endl;
        return;
    }

    std::string campo = (dynamic_cast<InfoRefCampo*>(c_dados))->get_nome_campo();
    Operando* instancia_classe = frame->desempilhar();
    std::cout << "tamanho: " << instancia_classe->obj->referencias.size() << std::endl;
    frame->empilhar(instancia_classe->obj->referencias[campo]);
    // frame->pc++;
}

// 181 (0xB5)
/**
 * @brief Define campo no objeto
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos. 
 * 
 * O indexbyte1 e indexbyte2 sem sinal s√£o usados ‚Äã‚Äãpara construir um √≠ndice no constant pool de tempo de execu√ß√£o da classe atual, em que o valor do √≠ndice √© (indexbyte1 << 8) | indexbyte2.
 * O item de constant pool em tempo de execu√ß√£o nesse √≠ndice deve ser uma refer√™ncia simb√≥lica a um campo, que fornece o nome e o descritor do campo, bem como uma refer√™ncia simb√≥lica √† classe na qual o campo deve ser encontrado. A classe de objectref n√£o deve ser uma matriz.
 * Se o campo estiver protegido e for membro de uma superclasse da classe atual, e o campo n√£o for declarado no mesmo pacote de tempo de execu√ß√£o da classe atual, a classe de objectref deve ser a classe atual ou uma subclasse da classe atual.
 * O campo referenciado √© resolvido. O tipo de valor armazenado por uma instru√ß√£o putfield deve ser compat√≠vel com o descritor do campo referenciado. 
 * Se o tipo de descritor de campo for booleano, byte, char, short ou int, o valor dever√° ser um int.
 * Se o tipo de descritor de campo for flutuante, longo ou duplo, o valor dever√° ser flutuante, longo ou duplo, respectivamente.
 * Se o tipo de descritor de campo for um tipo de refer√™ncia, o valor dever√° ser de um tipo compat√≠vel com a atribui√ß√£o (JLS ¬ß5.2) com o tipo de descritor de campo. Se o campo for final, ele deve ser declarado na classe atual e a instru√ß√£o deve ocorrer em um m√©todo de inicializa√ß√£o de inst√¢ncia (<init>) da classe atual (¬ß2.9).
 * O valor e objectref s√£o removidos da pilha de operandos. O objectref deve ser de refer√™ncia do tipo.
 * O valor passa pela convers√£o de valores, e o campo referenciado no objectref √© definido como valor.
 * 
 */
void manipulador_putfield (Frame *frame){
    u1 byte_1 = frame->get_prox_byte();
    u1 byte_2 = frame->get_prox_byte();
    u2 indice = (byte_1 << 8) | byte_2;

    InterCPDado *c_dados = frame->buscar_simbolo(indice);
    if (!c_dados){
        std::cout << "N√£o existe dados no √≠ndice: " << (int) indice << std::endl;
        return;
    }
    std::string nome_campo = (dynamic_cast<InfoRefCampo*>(c_dados))->get_nome_campo();


    Operando *op = frame->desempilhar();

    Operando* instancia_classe = frame->desempilhar();

    if(instancia_classe->obj != nullptr) {
        Operando* atributo = instancia_classe->obj->referencias[nome_campo];
        if(atributo == nullptr) {
            atributo = new Operando();
        }

        atributo->tag = op->tag;

        switch(op->tag){
            case TAG_INT:
                atributo->tipo_int = op->tipo_int;
                break;
            case TAG_LNG:
                atributo->tipo_long = op->tipo_long;
                break;
            case TAG_CHR:
                atributo->tipo_char = op->tipo_char;
                break;
            case TAG_SHT:
                atributo->tipo_short = op->tipo_short;
                break;
            case TAG_BYTE:
                atributo->tipo_byte = op->tipo_byte;
                break;
            case TAG_FLT:
                atributo->tipo_float = op->tipo_float;
                break;
            case TAG_DBL:
                atributo->tipo_double = op->tipo_double;
                break;
            case TAG_STR:
                atributo->tipo_string = op->tipo_string;
                break;
            case TAG_CLAS:
                atributo->obj = op->obj;
                break;
            default:
                break;
        }
        instancia_classe->obj->referencias[nome_campo] = atributo;
    }

    frame->pc++;
}

// 182 (0xB6)
/**
 * @brief Invocar m√©todo de inst√¢ncia e expedi√ß√£o com base na classe
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos. 
 * 
 * O indexbyte1 e indexbyte2 sem sinal s√£o usados ‚Äã‚Äãpara construir um √≠ndice no constant pool de tempo de execu√ß√£o da classe atual, em que o valor do √≠ndice √© (indexbyte1 << 8) | indexbyte2.
 * O item de pconstant pool em tempo de execu√ß√£o nesse √≠ndice deve ser uma refer√™ncia simb√≥lica a um m√©todo, que fornece o nome e o descritor do m√©todo, bem como uma refer√™ncia simb√≥lica √† classe na qual o m√©todo deve ser encontrado. O m√©todo nomeado √© resolvido. 
 * O m√©todo resolvido n√£o deve ser um m√©todo de inicializa√ß√£o de inst√¢ncia ou o m√©todo de inicializa√ß√£o de classe ou interface. 
 * Por fim, se o m√©todo resolvido estiver protegido e for membro de uma superclasse da classe atual, e o m√©todo n√£o for declarado no mesmo pacote de tempo de execu√ß√£o da classe atual, o comando classe de objectref deve ser a classe atual ou uma subclasse da classe atual.
 * Se o m√©todo resolvido n√£o for polim√≥rfico de assinatura, a instru√ß√£o invokevirtual ser√° da seguinte maneira.
 * Seja C a classe de objectref. O m√©todo real a ser chamado √© selecionado pelo seguinte procedimento de pesquisa:
 * Se C contiver uma declara√ß√£o para um m√©todo de inst√¢ncia m que substitua o m√©todo resolvido, ent√£o m √© o m√©todo a ser invocado e o procedimento de pesquisa √© encerrado.
 * Caso contr√°rio, se C tiver uma superclasse, esse mesmo procedimento de pesquisa ser√° executado recursivamente usando a superclasse direta de C; o m√©todo a ser invocado √© o resultado da invoca√ß√£o recursiva deste procedimento de pesquisa.
 * Caso contr√°rio, um AbstractMethodError √© gerado.
 * O objectref deve ser seguido na pilha de operandos pelos valores do argumento n args, em que o n√∫mero, tipo e ordem dos valores devem ser consistentes com o descritor do m√©todo de inst√¢ncia selecionado.
 * Se o m√©todo for sincronizado, o monitor associado ao objectref ser√° inserido ou reinserido como se fosse pela execu√ß√£o de uma instru√ß√£o do monitorenter (¬ßmonitorenter) no encadeamento atual.
 * Se o m√©todo n√£o for nativo, os valores do argumento nargs e objectref ser√£o exibidos na pilha de operandos. Um novo quadro √© criado na pilha da Java Virtual Machine para o m√©todo que est√° sendo chamado. Os valores objectref e argumento s√£o transformados consecutivamente nos valores das vari√°veis ‚Äã‚Äãlocais do novo quadro, com objectref na vari√°vel local 0, arg1 na vari√°vel local 1 (ou, se arg1 for do tipo longo ou duplo, nas vari√°veis ‚Äã‚Äãlocais 1 e 2) , e assim por diante. Qualquer valor de argumento que seja do tipo de ponto flutuante passa pela convers√£o do conjunto de valores (¬ß2.8.3) antes de ser armazenado em uma vari√°vel local. O novo quadro √© atualizado e o Java Virtual Machine pc √© definido como o c√≥digo de opera√ß√£o da primeira instru√ß√£o do m√©todo a ser chamado. A execu√ß√£o continua com a primeira instru√ß√£o do m√©todo.
 * Se o m√©todo for nativo e o c√≥digo dependente da plataforma que o implementa ainda n√£o tiver sido vinculado (¬ß5.6) √† Java Virtual Machine, isso ser√° feito. Os valores do argumento nargs e objectref s√£o removidos da pilha de operandos e s√£o passados ‚Äã‚Äãcomo par√¢metros para o c√≥digo que implementa o m√©todo. Qualquer valor de argumento que seja do tipo de ponto flutuante passa pela convers√£o do conjunto de valores (¬ß2.8.3) antes de ser passado como par√¢metro. Os par√¢metros s√£o passados ‚Äã‚Äãe o c√≥digo √© chamado de uma maneira dependente da implementa√ß√£o. Quando o c√≥digo dependente da plataforma retorna, ocorre o seguinte:
 * Se o m√©todo nativo estiver sincronizado, o monitor associado ao objectref ser√° atualizado e possivelmente encerrado como se estivesse executando uma instru√ß√£o de monitorexit (¬ßmonitorexit) no encadeamento atual.
 * Se o m√©todo nativo retornar um valor, o valor retornado do c√≥digo dependente da plataforma ser√° convertido de maneira dependente da implementa√ß√£o no tipo de retorno do m√©todo nativo e empurrado para a pilha de operandos.
 * Se o m√©todo resolvido for assinatura polim√≥rfica, a instru√ß√£o invokevirtual continuar√° da seguinte maneira.
 * Primeiro, uma refer√™ncia a uma inst√¢ncia de java.lang.invoke.MethodType √© obtida como se por resolu√ß√£o de uma refer√™ncia simb√≥lica a um tipo de m√©todo (¬ß5.4.3.5) com o mesmo par√¢metro e tipos de retorno que o descritor do m√©todo referenciado por a instru√ß√£o invokevirtual.
 * Se o m√©todo nomeado for invokeExact, a inst√¢ncia de java.lang.invoke.MethodType dever√° ser semanticamente igual ao descritor de tipo do identificador do m√©todo de recebimento objectref. O identificador de m√©todo a ser chamado √© objectref.
 * Se o m√©todo nomeado for chamado, e a inst√¢ncia de java.lang.invoke.MethodType for semanticamente igual ao descritor de tipo do identificador do m√©todo receptor, objectref, o identificador do m√©todo a ser chamado ser√° objectref.
 * Se o m√©todo nomeado for chamado e a inst√¢ncia de java.lang.invoke.MethodType n√£o for semanticamente igual ao descritor de tipo do identificador do m√©todo de recebimento objectref, a Java Virtual Machine tentar√° ajustar o descritor de tipo do identificador do m√©todo de recebimento, como se por uma chamada para java.lang.invoke.MethodHandle.asType, para obter um m√©todo exatamente invoc√°vel, manipule m.
 * O identificador de m√©todo a ser chamado √© m.
 * O objectref deve ser seguido na pilha de operandos por n args
 * 
 */
void manipulador_invokevirtual (Frame *frame){
    u1 byte_1 = frame->get_prox_byte();
    u1 byte_2 = frame->get_prox_byte();
    u2 indice = (byte_1 << 8) | byte_2;

    InterCPDado *c_dados = frame->buscar_simbolo(indice);

    if (!c_dados){
        std::cout << "N√£o existe dados no √≠ndice: " << (int) indice << std::endl;
        return;
    }

    if (c_dados->tag != TAG_REF_MTD){
        std::cout << "N√£o √© poss√≠vel acessar um m√©todo com a refer√™ncia errada" << std::endl;
        std::cout << "\t" << get_tag(c_dados->tag) << " n√£o √© " << get_tag(TAG_REF_MTD) << std::endl;
        return;
    }

    std::string nome_classe = (dynamic_cast<InfoRefMetodo*>(c_dados))->get_nome_classe();

    if (!nome_classe.compare("java/io/PrintStream")){
        std::cout << frame->desempilhar()->get();

        if (!(dynamic_cast<InfoRefMetodo*>(c_dados))->get_nome_metodo().compare("println"))
            std::cout << std::endl;

        frame->pc++;

        return;
    }

    frame->pc++;
    frame->a_empilhar = c_dados;
}

// 183 (0xB7)
/**
 * @brief Invocar m√©todo de inst√¢ncia e manipula√ß√£o especial para chamadas de m√©todo de inicializa√ß√£o de superclasse, privada e inst√¢ncia
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos. 
 * 
 * O indexbyte1 e indexbyte2 sem sinal s√£o usados ‚Äã‚Äãpara construir um √≠ndice no pool constante de tempo de execu√ß√£o da classe atual, em que o valor do √≠ndice √© (indexbyte1 << 8) | indexbyte2. 
 * O item de constant pool em tempo de execu√ß√£o nesse √≠ndice deve ser uma refer√™ncia simb√≥lica a um m√©todo, que fornece o nome e o descritor do m√©todo, bem como uma refer√™ncia simb√≥lica √† classe na qual o m√©todo deve ser encontrado. O m√©todo nomeado √© resolvido. 
 * Por fim, se o m√©todo resolvido estiver protegido e for membro de uma superclasse da classe atual, e o m√©todo n√£o for declarado no mesmo pacote de tempo de execu√ß√£o da classe atual, o comando classe de objectref deve ser a classe atual ou uma subclasse da classe atual.
 * Em seguida, o m√©todo resolvido √© selecionado para chamada, a menos que todas as seguintes condi√ß√µes sejam verdadeiras:
 * O sinalizador ACC_SUPER est√° definido para a classe atual.
 * A classe do m√©todo resolvido √© uma superclasse da classe atual.
 * O m√©todo resolvido n√£o √© um m√©todo de inicializa√ß√£o de inst√¢ncia
 * Se as condi√ß√µes acima forem verdadeiras, o m√©todo real a ser chamado √© selecionado pelo seguinte procedimento de pesquisa. Seja C a superclasse direta da classe atual:
 * Se C contiver uma declara√ß√£o para um m√©todo de inst√¢ncia com o mesmo nome e descritor que o m√©todo resolvido, esse m√©todo ser√° chamado. O procedimento de pesquisa termina.
 * Caso contr√°rio, se C tiver uma superclasse, esse mesmo procedimento de pesquisa ser√° executado recursivamente usando a superclasse direta de C. O m√©todo a ser invocado √© o resultado da invoca√ß√£o recursiva desse procedimento de pesquisa.
 * Caso contr√°rio, um AbstractMethodError √© gerado.
 * O objectref deve ser de refer√™ncia de tipo e deve ser seguido na pilha de operandos pelos valores do argumento nargs, em que o n√∫mero, o tipo e a ordem dos valores devem ser consistentes com o descritor do m√©todo de inst√¢ncia selecionado.
 * Se o m√©todo for sincronizado, o monitor associado ao objectref ser√° inserido ou reinserido como se fosse pela execu√ß√£o de uma instru√ß√£o do monitorenter no encadeamento atual.
 * Se o m√©todo n√£o for nativo, os valores do argumento nargs e objectref ser√£o exibidos na pilha de operandos. Um novo quadro √© criado na pilha da Java Virtual Machine para o m√©todo que est√° sendo chamado.
 * Os valores objectref e argumento s√£o transformados consecutivamente nos valores das vari√°veis ‚Äã‚Äãlocais do novo quadro, com objectref na vari√°vel local 0, arg1 na vari√°vel local 1 (ou, se arg1 for do tipo longo ou duplo, nas vari√°veis ‚Äã‚Äãlocais 1 e 2) , e assim por diante. Qualquer valor de argumento que seja do tipo de ponto flutuante passa pela convers√£o do conjunto de valores antes de ser armazenado em uma vari√°vel local.
 * O novo quadro √© atualizado e o Java Virtual Machine pc √© definido como o c√≥digo de opera√ß√£o da primeira instru√ß√£o do m√©todo a ser chamado.
 * A execu√ß√£o continua com a primeira instru√ß√£o do m√©todo.
 * Se o m√©todo for nativo e o c√≥digo dependente da plataforma que o implementa ainda n√£o tiver sido vinculado √† Java Virtual Machine, isso ser√° feito. Os valores do argumento nargs e objectref s√£o removidos da pilha de operandos e s√£o passados ‚Äã‚Äãcomo par√¢metros para o c√≥digo que implementa o m√©todo. 
 * Qualquer valor de argumento que seja do tipo de ponto flutuante passa pela convers√£o do conjunto de valores antes de ser passado como par√¢metro. 
 * Os par√¢metros s√£o passados ‚Äã‚Äãe o c√≥digo √© chamado de uma maneira dependente da implementa√ß√£o. 
 * Quando o c√≥digo dependente da plataforma retorna, ocorre o seguinte:
 * e o m√©todo nativo estiver sincronizado, o monitor associado ao objectref ser√° atualizado e possivelmente encerrado como se estivesse executando uma instru√ß√£o de monitorexit no encadeamento atual.
 * Se o m√©todo nativo retornar um valor, o valor retornado do c√≥digo dependente da plataforma ser√° convertido de maneira dependente da implementa√ß√£o no tipo de retorno do m√©todo nativo e empurrado para a pilha de operandos.
 * 
 */
void manipulador_invokespecial (Frame *frame){
    u1 byte_1 = frame->get_prox_byte();
    u1 byte_2 = frame->get_prox_byte();
    u2 indice = (byte_1 << 8) | byte_2;

    InterCPDado *c_dados = frame->buscar_simbolo(indice);

    if (!c_dados){
        std::cout << "N√£o existe dados no √≠ndice: " << (int) indice << std::endl;
        return;
    }

    if ((c_dados->tag != TAG_REF_MTD) && (c_dados->tag != TAG_REF_MTD_ITF)){
        std::cout << "N√£o √© poss√≠vel acessar um m√©todo com a refer√™ncia errada" << std::endl;
        std::cout << "\t" << get_tag(c_dados->tag) << " n√£o √© " << get_tag(TAG_REF_MTD);
        std::cout << " nem " << get_tag(TAG_REF_MTD_ITF) << std::endl;
        return;
    }

    exibir_se_verboso("\t#" + std::to_string((int) indice) + " -> " + c_dados->get());

    frame->a_empilhar = c_dados;
    frame->pc++;
}

// 184 (0xB8)
/**
 * @brief Invocar um m√©todo de classe (est√°tico)
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos. 
 * 
 * O indexbyte1 e indexbyte2 sem sinal s√£o usados ‚Äã‚Äãpara construir um √≠ndice no constant pool de tempo de execu√ß√£o da classe atual, em que o valor do √≠ndice √© (indexbyte1 << 8) | indexbyte2.
 * O item de pconstant pool em tempo de execu√ß√£o nesse √≠ndice deve ser uma refer√™ncia simb√≥lica a um m√©todo, que fornece o nome e o descritor do m√©todo, bem como uma refer√™ncia simb√≥lica √† classe na qual o m√©todo deve ser encontrado.
 * O m√©todo nomeado √© resolvido. 
 * O m√©todo resolvido n√£o deve ser um m√©todo de inicializa√ß√£o de inst√¢ncia ou o m√©todo de inicializa√ß√£o de classe ou interface.
 * Deve ser est√°tico e, portanto, n√£o pode ser abstrato.
 * Na resolu√ß√£o bem-sucedida do m√©todo, a classe que declarou o m√©todo resolvido √© inicializada se essa classe ainda n√£o tiver sido inicializada.
 * A pilha de operandos deve conter valores de argumentos de nargs, em que o n√∫mero, tipo e ordem dos valores devem ser consistentes com o descritor do m√©todo resolvido.
 * Se o m√©todo estiver sincronizado, o monitor associado ao objeto Classe resolvido ser√° inserido ou reinserido como se fosse pela execu√ß√£o de uma instru√ß√£o do monitorenter (¬ßmonitorenter) no encadeamento atual.
 * Se o m√©todo n√£o for nativo, os valores do argumento nargs ser√£o exibidos na pilha de operandos. 
 * Um novo quadro √© criado na pilha da Java Virtual Machine para o m√©todo que est√° sendo chamado.
 * Os valores do argumento nargs s√£o transformados consecutivamente nos valores das vari√°veis ‚Äã‚Äãlocais do novo quadro, com arg1 na vari√°vel local 0 (ou, se arg1 for do tipo longo ou duplo, nas vari√°veis ‚Äã‚Äãlocais 0 e 1) e assim por diante. 
 * Qualquer valor de argumento que seja do tipo de ponto flutuante passa pela convers√£o do conjunto de valores antes de ser armazenado em uma vari√°vel local. 
 * O novo quadro √© atualizado e o Java Virtual Machine pc √© definido como o c√≥digo de opera√ß√£o da primeira instru√ß√£o do m√©todo a ser chamado.
 * A execu√ß√£o continua com a primeira instru√ß√£o do m√©todo.
 * Se o m√©todo for nativo e o c√≥digo dependente da plataforma que o implementa ainda n√£o tiver sido vinculado √† Java Virtual Machine, isso ser√° feito. 
 * Os valores do argumento nargs s√£o removidos da pilha de operandos e s√£o passados ‚Äã‚Äãcomo par√¢metros para o c√≥digo que implementa o m√©todo. 
 * Qualquer valor de argumento que seja do tipo de ponto flutuante passa pela convers√£o do conjunto de valores antes de ser passado como par√¢metro. 
 * Os par√¢metros s√£o passados ‚Äã‚Äãe o c√≥digo √© chamado de uma maneira dependente da implementa√ß√£o.
 * Quando o c√≥digo dependente da plataforma retorna, ocorre o seguinte:
 * Se o m√©todo nativo for sincronizado, o monitor associado ao objeto Classe resolvido ser√° atualizado e possivelmente encerrado como se fosse pela execu√ß√£o de uma instru√ß√£o de monitorexit (¬ßmonitorexit) no encadeamento atual.
 * Se o m√©todo nativo retornar um valor, o valor retornado do c√≥digo dependente da plataforma ser√° convertido de maneira dependente da implementa√ß√£o no tipo de retorno do m√©todo nativo e empurrado para a pilha de operandos.
 * 
 */
void manipulador_invokestatic (Frame *frame){
    u1 byte_1 = frame->get_prox_byte();
    u1 byte_2 = frame->get_prox_byte();
    u2 indice = (byte_1 << 8) | byte_2;

    InterCPDado *c_dados = frame->buscar_simbolo(indice);

    if (!c_dados){
        std::cout << "N√£o existe dados no √≠ndice: " << indice << std::endl;
        return;
    }

    if ((c_dados->tag != TAG_REF_MTD) && (c_dados->tag != TAG_REF_MTD_ITF)){
        std::cout << "N√£o √© poss√≠vel acessar um m√©todo est√°tico com a refer√™ncia errada" << std::endl;
        std::cout << "\t" << get_tag(c_dados->tag) << " n√£o √© " << get_tag(TAG_REF_MTD);
        std::cout << " nem " << get_tag(TAG_REF_MTD_ITF) << std::endl;
        return;
    }

    frame->a_empilhar = c_dados;
    frame->pc++;
}

// rever-
// 185 (0xB9)
/**
 * @brief Invocar o m√©todo da interface
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos. 
 * 
 * O indexbyte1 e indexbyte2 sem sinal s√£o usados ‚Äã‚Äãpara construir um √≠ndice no constant pool de tempo de execu√ß√£o da classe atual, em que o valor do √≠ndice √© (indexbyte1 << 8) | indexbyte2.
 * O item de constant pool em tempo de execu√ß√£o nesse √≠ndice deve ser uma refer√™ncia simb√≥lica a um m√©todo de interface, que fornece o nome e o descritor do m√©todo de interface, bem como uma refer√™ncia simb√≥lica √† interface em qual o m√©todo de interface deve ser encontrado. 
 * O m√©todo da interface nomeada foi resolvido.
 * O m√©todo de interface resolvido n√£o deve ser um m√©todo de inicializa√ß√£o de inst√¢ncia ou o m√©todo de inicializa√ß√£o de classe ou interface.
 * O operando de contagem √© um byte n√£o assinado que n√£o deve ser zero.
 * O objectref deve ser de refer√™ncia de tipo e deve ser seguido na pilha de operandos pelos valores do argumento nargs, em que o n√∫mero, o tipo e a ordem dos valores devem ser consistentes com o descritor do m√©todo da interface resolvida.
 * O valor do quarto byte do operando deve sempre ser zero.
 * Seja C a classe de objectref. O m√©todo real a ser chamado √© selecionado pelo seguinte procedimento de pesquisa:
 * Se C contiver uma declara√ß√£o para um m√©todo de inst√¢ncia com o mesmo nome e descritor que o m√©todo resolvido, esse √© o m√©todo a ser chamado e o procedimento de pesquisa ser√° encerrado.
 * Caso contr√°rio, se C tiver uma superclasse, esse mesmo procedimento de pesquisa ser√° executado recursivamente usando a superclasse direta de C; o m√©todo a ser invocado √© o resultado da invoca√ß√£o recursiva deste procedimento de pesquisa.
 * Caso contr√°rio, um AbstractMethodError √© gerado.
 * Se o m√©todo for sincronizado, o monitor associado ao objectref ser√° inserido ou reinserido como se fosse pela execu√ß√£o de uma instru√ß√£o do monitorenter (¬ßmonitorenter) no encadeamento atual.
 * Se o m√©todo n√£o for nativo, os valores do argumento nargs e objectref ser√£o exibidos na pilha de operandos. Um novo quadro √© criado na pilha da Java Virtual Machine para o m√©todo que est√° sendo chamado.
 * Os valores objectref e argumento s√£o transformados consecutivamente nos valores das vari√°veis ‚Äã‚Äãlocais do novo quadro, com objectref na vari√°vel local 0, arg1 na vari√°vel local 1 (ou, se arg1 for do tipo longo ou duplo, nas vari√°veis ‚Äã‚Äãlocais 1 e 2) , e assim por diante. 
 * Qualquer valor de argumento que seja do tipo de ponto flutuante passa pela convers√£o do conjunto de valores antes de ser armazenado em uma vari√°vel local.
 * O novo quadro √© atualizado e o Java Virtual Machine pc √© definido como o c√≥digo de opera√ß√£o da primeira instru√ß√£o do m√©todo a ser chamado.
 * A execu√ß√£o continua com a primeira instru√ß√£o do m√©todo.
 * Se o m√©todo for nativo e o c√≥digo dependente da plataforma que o implementa ainda n√£o tiver sido vinculado √† Java Virtual Machine, isso ser√° feito. 
 * Os valores do argumento nargs e objectref s√£o removidos da pilha de operandos e s√£o passados ‚Äã‚Äãcomo par√¢metros para o c√≥digo que implementa o m√©todo.
 * Qualquer valor de argumento que seja do tipo de ponto flutuante passa pela convers√£o do conjunto de valores antes de ser passado como par√¢metro.
 * Os par√¢metros s√£o passados ‚Äã‚Äãe o c√≥digo √© chamado de uma maneira dependente da implementa√ß√£o. 
 * Quando o c√≥digo dependente da plataforma retornar:
 * Se o m√©todo nativo estiver sincronizado, o monitor associado ao objectref ser√° atualizado e possivelmente encerrado como se estivesse executando uma instru√ß√£o de monitorexit (¬ßmonitorexit) no encadeamento atual.
 * Se o m√©todo nativo retornar um valor, o valor retornado do c√≥digo dependente da plataforma ser√° convertido de maneira dependente da implementa√ß√£o no tipo de retorno do m√©todo nativo e empurrado para a pilha de operandos.
 *  
 */
void manipulador_invokeinterface (Frame *frame){
    u1 byte_1 = frame->get_prox_byte();
    u1 byte_2 = frame->get_prox_byte();
    u2 indice = (byte_1 << 8) | byte_2;

    InterCPDado *c_dados = frame->buscar_simbolo(indice);

    if (!c_dados){
        std::cout << "N√£o existe dados no √≠ndice: " << (int) indice << std::endl;
        return;
    }

    if ((c_dados->tag != TAG_REF_MTD) && (c_dados->tag != TAG_REF_MTD_ITF)){
        std::cout << "N√£o √© poss√≠vel acessar um m√©todo com a refer√™ncia errada" << std::endl;
        std::cout << "\t" << get_tag(c_dados->tag) << " n√£o √© " << get_tag(TAG_REF_MTD);
        std::cout << " nem " << get_tag(TAG_REF_MTD_ITF) << std::endl;
        return;
    }

    exibir_se_verboso("\t#" + std::to_string((int) indice) + " -> " + c_dados->get());

    frame->a_empilhar = c_dados;
    frame->pc++;
}

// add
// 186 (0xBA)
/**
 * @brief Invocar m√©todo din√¢mico
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos. 
 * 
 * Cada ocorr√™ncia lexical espec√≠fica de uma instru√ß√£o din√¢mica invocada √© chamada de site de chamada din√¢mica.
 * Primeiro, o indexbyte1 e o indexbyte2 n√£o assinados s√£o usados ‚Äã‚Äãpara construir um √≠ndice no constant pool de tempo de execu√ß√£o da classe atual, em que o valor do √≠ndice √© (indexbyte1 << 8) | indexbyte2. O item de pool constante em tempo de execu√ß√£o nesse √≠ndice deve ser uma refer√™ncia simb√≥lica a um especificador de site de chamada. Os valores do terceiro e quarto bytes do operando devem sempre ser zero.
 * O especificador do site de chamada foi resolvido para que este site de chamada din√¢mico espec√≠fico obtenha uma refer√™ncia a uma inst√¢ncia java.lang.invoke.MethodHandle, uma refer√™ncia a uma inst√¢ncia java.lang.invoke.MethodType e refer√™ncias a static argumentos.
 * Em seguida, como parte da resolu√ß√£o cont√≠nua do especificador do site de chamada, o m√©todo de autoinicializa√ß√£o √© chamado como se fosse pela execu√ß√£o de uma instru√ß√£o virtual invokevirtual (¬ßinvokevirtual) que contenha um √≠ndice de pool constante em tempo de execu√ß√£o para uma refer√™ncia simb√≥lica a um m√©todo com as seguintes propriedades:
 * O nome do m√©todo √© invocado;
 * O descritor do m√©todo possui um tipo de retorno java.lang.invoke.CallSite;
 * O descritor do m√©todo possui tipos de par√¢metros derivados dos itens enviados para a pilha de operandos, conforme a seguir.
 * Os quatro primeiros tipos de par√¢metros no descritor s√£o
 * java.lang.invoke.MethodHandle,
 * java.lang.invoke.MethodHandles.Lookup, String e 
 * java.lang.invoke.MethodType, nessa ordem.
 * Se o especificador do site de chamada tiver argumentos est√°ticos, um tipo de par√¢metro para cada argumento ser√° anexado aos tipos de par√¢metros do descritor de m√©todo na ordem em que os argumentos foram enviados √† pilha de operandos.
 * Esses tipos de par√¢metros podem ser Class, java.lang.invoke.MethodHandle, java.lang.invoke.MethodType, String, int, long, float ou double.
 * A refer√™ncia simb√≥lica do m√©todo √† classe na qual o m√©todo deve ser encontrado indica a classe java.lang.invoke.MethodHandle.
 * onde √© como se os seguintes itens fossem empurrados, em ordem, para a pilha de operandos:
 * a refer√™ncia ao objeto java.lang.invoke.MethodHandle para o m√©todo de autoinicializa√ß√£o;
 * uma refer√™ncia a um objeto java.lang.invoke.MethodHandles.Lookup para a classe na qual esse site de chamada din√¢mica ocorre;
 * uma refer√™ncia √† String para o nome do m√©todo no especificador do site de chamada;
 * a refer√™ncia ao objeto java.lang.invoke.MethodType obtido para o descritor de m√©todo no especificador de site de chamada;
 * refer√™ncias a classes, tipos de m√©todos, identificadores de m√©todos e literais de cadeia de caracteres denotados como argumentos est√°ticos no especificador do site de chamada e valores num√©ricos denotados como argumentos est√°ticos no especificador de site de chamada, na ordem em que eles aparecem no especificador do site de chamada.
 * (Ou seja, n√£o ocorre boxe para valores primitivos.)
 * Desde que o m√©todo de autoinicializa√ß√£o possa ser invocado corretamente pelo m√©todo de invoca√ß√£o, seu descritor √© arbitr√°rio.
 * Por exemplo, o primeiro tipo de par√¢metro pode ser Object, em vez de java.lang.invoke.MethodHandles.Lookup, e o tipo de retorno tamb√©m pode ser Object, em vez de java.lang.invoke.CallSite.
 * Se o m√©todo de autoinicializa√ß√£o for um m√©todo de vari√°vel vari√°vel, alguns ou todos os argumentos na pilha de operandos especificados acima podem ser coletados em um par√¢metro de matriz √† direita.
 * A chamada de um m√©todo de autoinicializa√ß√£o ocorre dentro de um encadeamento que est√° tentando resolver a refer√™ncia simb√≥lica ao especificador do site de chamada deste site de chamada din√¢mico.
 * Se houver v√°rios desses segmentos, o m√©todo de autoinicializa√ß√£o poder√° ser chamado em v√°rios segmentos simultaneamente. 
 * Portanto, os m√©todos de autoinicializa√ß√£o que acessam os dados globais do aplicativo devem tomar as precau√ß√µes habituais contra as condi√ß√µes de corrida.
 * O resultado retornado pelo m√©todo bootstrap deve ser uma refer√™ncia a um objeto cuja classe √© java.lang.invoke.CallSite ou uma subclasse de java.lang.invoke.CallSite. 
 * Este objeto √© conhecido como objeto de site de chamada. A refer√™ncia √© exibida na pilha de operandos usada como se estivesse na execu√ß√£o de uma instru√ß√£o invokevirtual.
 * Se v√°rios encadeamentos executam simultaneamente o m√©todo de autoinicializa√ß√£o para o mesmo site de chamada din√¢mico, a Java Virtual Machine deve escolher um objeto de site de chamada retornado e instal√°-lo visivelmente em todos os encadeamentos.
 * Todos os outros m√©todos de inicializa√ß√£o executados para o site de chamada din√¢mico podem ser conclu√≠dos, mas seus resultados s√£o ignorados e a execu√ß√£o dos threads do site de chamada din√¢mica continua com o objeto de site de chamada escolhido.
 * O objeto do site de chamada possui um descritor de tipo (uma inst√¢ncia de java.lang.invoke.MethodType) que deve ser semanticamente igual ao objeto java.lang.invoke.MethodType obtido para o descritor de m√©todo no especificador de site de chamada.
 * O resultado da resolu√ß√£o bem-sucedida do especificador de site de chamada √© um objeto de site de liga√ß√£o permanentemente vinculado ao site de chamada din√¢mico.
 * O identificador de m√©todo representado pelo destino do objeto de site de chamada vinculada √© chamado. A invoca√ß√£o ocorre como se pela execu√ß√£o de uma instru√ß√£o invokevirtual (¬ßinvokevirtual) que indica um √≠ndice de pool constante em tempo de execu√ß√£o para uma refer√™ncia simb√≥lica a um m√©todo com as seguintes propriedades:
 * O nome do m√©todo √© invokeExact;
 * 
 */
void manipulador_invokedynamic (Frame *frame){
    frame->pc += bytecodes[186].bytes + 1;
}

// 187 (0xBB)
/**
 * @brief Criar novo objeto
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos. 
 * 
 * O indexbyte1 e indexbyte2 sem sinal s√£o usados para construir um √≠ndice no contant pool de tempo de execu√ß√£o da classe atual, em que o valor do √≠ndice √© (indexbyte1 << 8) | indexbyte2. 
 * O item de constant pool em tempo de execu√ß√£o no √≠ndice deve ser uma refer√™ncia simb√≥lica a um tipo de classe ou interface.
 * A classe nomeada ou o tipo de interface √© resolvido e deve resultar em um tipo de classe.
 * A mem√≥ria para uma nova inst√¢ncia dessa classe √© alocada a partir do heap coletado pelo lixo e as vari√°veis de inst√¢ncia do novo objeto s√£o inicializadas com seus valores iniciais padr√£o.
 * O objectref, uma refer√™ncia √† inst√¢ncia, √© empurrado para a pilha de operandos.
 * Na resolu√ß√£o bem-sucedida da classe, ela √© inicializada se ainda n√£o tiver sido inicializada.
 * 
 */
void manipulador_new (Frame *frame){
    u1 byte_1 = frame->get_prox_byte();
    u1 byte_2 = frame->get_prox_byte();
    u2 indice = (byte_1 << 8) | byte_2;

    InterCPDado *c_dados = frame->buscar_simbolo(indice);

    if (!c_dados){
        std::cout << "N√£o existe dados no √≠ndice: " << indice << std::endl;
        return;
    }

    frame->a_empilhar = c_dados;
    frame->pc++;
}

// 188 (0xBC)
/**
 * @brief Criar novo array
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos. 
 * 
 * A contagem deve ser do tipo inteiro. 
 * √â retirado da pilha de operandos. 
 * A contagem representa o n√∫mero de elementos na matriz a ser criada.
 * O atype √© um c√≥digo que indica o tipo de matriz a ser criada. Ele deve assumir um dos seguintes valores:
 * Array Type   atype
 * T_BOOLEAN    4
 * T_CHAR       5
 * T_FLOAT      6
 * T_DOUBLE     7
 * T_BYTE       8
 * T_SHORT      9
 * T_INT        10
 * T_LONG       11
 * Uma nova matriz cujos componentes s√£o do tipo atype e da contagem de comprimento √© alocada no heap coletado pelo lixo.
 * Uma matriz de refer√™nciaref para esse novo objeto de matriz √© enviada para a pilha de operandos.
 * Cada um dos elementos da nova matriz √© inicializado com o valor inicial padr√£o para o tipo de elemento do tipo de matriz.
 * 
 */
void manipulador_newarray (Frame *frame){
    Operando *quantidade = frame->desempilhar();

    if (!quantidade){
        std::cout << "N√£o houve o que desempilhar" << std::endl;
        return;
    }

    u1 tipo_array = frame->get_prox_byte();

    int qnt = (int) quantidade->tipo_int;

    Operando *array = new Operando();
    array->tag = TAG_ARR;

    array->lista_operandos = new std::vector<Operando*>();

    for (int cnt = 0; cnt < qnt; cnt++){
        Operando *op = new Operando();

        switch (tipo_array){
            case ARR_BLN: op->tag = TAG_BLN; break;
            case ARR_CHR: op->tag = TAG_CHR; break;
            case ARR_FLT: op->tag = TAG_FLT; break;
            case ARR_DBL: op->tag = TAG_DBL; break;
            case ARR_BYTE: op->tag = TAG_BYTE; break;
            case ARR_SHT: op->tag = TAG_SHT; break;
            case ARR_INT: op->tag = TAG_INT; break;
            case ARR_LNG: op->tag = TAG_LNG; break;
            default: op->tag = TAG_VAZ;
        }

        if (op->tag != TAG_VAZ)
            array->lista_operandos->push_back(op);

    }

    exibir_se_verboso("\tCriado um vetor com " + std::to_string(qnt) + " itens do tipo "
        + std::to_string(tipo_array));

    frame->empilhar(array);
    frame->pc++;
}

// 189 (0xBD)
/**
 * @brief Crie uma nova matriz de refer√™ncia
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos. 
 * 
 * A contagem deve ser do tipo inteiro.
 * √â retirado da pilha de operandos.
 * A contagem representa o n√∫mero de componentes da matriz a ser criada.
 * O indexbyte1 e indexbyte2 sem sinal s√£o usados para construir um √≠ndice no pool constante de tempo de execu√ß√£o da classe atual, em que o valor do √≠ndice √© (indexbyte1 << 8) | indexbyte2.
 * O item de constant pool em tempo de execu√ß√£o nesse √≠ndice deve ser uma refer√™ncia simb√≥lica a uma classe, matriz ou tipo de interface.
 * A classe, matriz ou tipo de interface nomeado √© resolvido.
 * Uma nova matriz com componentes desse tipo, de contagem de comprimento, √© alocada a partir da pilha coletada de lixo e uma matriz de refer√™nciaref para esse novo objeto de matriz √© enviada para a pilha de operandos.
 * Todos os componentes da nova matriz s√£o inicializados como nulos, o valor padr√£o para os tipos de refer√™ncia
 * 
 */
void manipulador_anewarray (Frame *frame){
    frame->pc += bytecodes[189].bytes + 1;
}

// 190 (0xBE)
/**
 * @brief Calcula o tamanho de um vetor
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos. 
 * 
 * O arraydef deve ser do tipo refer√™ncia e deve se referir √† um vetor. √â obtido pegando o primeiro elemento da pilha. O tamanho do vetor √© determinado e colocado no topo da pilha de operandos.
 */
void manipulador_arraylength (Frame *frame){
    Operando *array = frame->desempilhar();
    Operando *tamanho = new Operando();
    tamanho->tag = TAG_INT;

    if (array->tag != TAG_ARR || !array->lista_operandos)
        tamanho->tipo_int = 0;
    else
        tamanho->tipo_int = array->lista_operandos->size();

    frame->empilhar(tamanho);
    frame->pc++;
}

// 191 (0xBF)
/**
 * @brief Lan√ßar excess√£o ou erro
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos. 
 * 
 * O objectref deve ser do tipo refer√™ncia e deve se referir a um objeto que √© uma inst√¢ncia da classe Throwable ou de uma subclasse de Throwable. √â retirado da pilha de operandos. O objectref √© ent√£o lan√ßado pesquisando no m√©todo atual o primeiro manipulador de exce√ß√µes que corresponda √† classe de objectref
 * Se um manipulador de exce√ß√£o que corresponda ao objectref for encontrado, ele conter√° o local do c√≥digo destinado a lidar com essa exce√ß√£o. O registro do pc √© redefinido para esse local, a pilha de operandos do frame atual √© limpa, o objectref √© empurrado de volta para a pilha de operandos e a execu√ß√£o continua.
 * Se nenhum manipulador de exce√ß√£o correspondente for encontrado no quadro atual, esse quadro ser√° exibido. Se o frame atual representa uma invoca√ß√£o de um m√©todo sincronizado, o monitor inserido ou reinserido na invoca√ß√£o do m√©todo √© encerrado como se estivesse executando uma instru√ß√£o de monitorexit
 * Finalmente, o quadro de seu invocador √© restabelecido, se esse quadro existir, e o objectref √© reapresentado. Se esse frame n√£o existir, o encadeamento atual ser√° encerrado.
 * 
 */
void manipulador_athrow (Frame *frame){
    frame->pc += bytecodes[191].bytes + 1;
}

// 192 (0xC0)
/**
 * @brief Verifica se um objeto √© de um certo tipo
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos. 
 * 
 * O objectref deve ser de refer√™ncia do tipo. O indexbyte1 e indexbyte2 n√£o assinado s√£o usados ‚Äã‚Äãpara construir um √≠ndice no pool constante de tempo de execu√ß√£o da classe atual (¬ß2.6), em que o valor do √≠ndice √© (indexbyte1 << 8) | indexbyte2. O item de pool constante em tempo de execu√ß√£o no √≠ndice deve ser uma refer√™ncia simb√≥lica a uma classe, matriz ou tipo de interface.
 * Se objectref for nulo, a pilha de operandos n√£o ser√° alterada.
 * Caso contr√°rio, a classe, matriz ou tipo de interface nomeado ser√° resolvido (¬ß5.4.3.1). Se objectref puder ser convertido para a classe resolvida, matriz ou tipo de interface, a pilha de operandos n√£o ser√° alterada; caso contr√°rio, a instru√ß√£o checkcast lan√ßa uma ClassCastException.
 * As regras a seguir s√£o usadas para determinar se um objectref que n√£o √© nulo pode ser convertido para o tipo resolvido: se S √© a classe do objeto referido por objectref e T √© o tipo de classe, matriz ou interface resolvido, o checkcast determina se objectref pode ser convertido para o tipo T da seguinte maneira:
 * Se S √© uma classe comum (sem matriz), ent√£o:
 * Se T √© um tipo de classe, ent√£o S deve ser a mesma classe que T ou S deve ser uma subclasse de T;
 * Se T √© um tipo de interface, S deve implementar a interface T.
 * Se S √© um tipo de interface, ent√£o:
 * Se T √© um tipo de classe, T deve ser Objeto.
 * Se T √© um tipo de interface, T deve ser a mesma interface que S ou uma superinterface de S.
 * Se S √© uma classe que representa o tipo de matriz SC [], ou seja, uma matriz de componentes do tipo SC, ent√£o:
 * Se T √© um tipo de classe, T deve ser Objeto.
 * Se T √© um tipo de interface, T deve ser uma das interfaces implementadas por matrizes (JLS ¬ß4.10.3).
 * Se T for um tipo de matriz TC [], ou seja, uma matriz de componentes do tipo TC, um dos seguintes dever√° ser verdadeiro:
 * TC e SC s√£o do mesmo tipo primitivo.
 * TC e SC s√£o tipos de refer√™ncia e o tipo SC pode ser convertido em TC pela aplica√ß√£o recursiva dessas regras.
 */
void manipulador_checkcast (Frame *frame){
    frame->pc += bytecodes[192].bytes + 1;
}

// 193 (0xC1)
/**
 * @brief Determinar se o objeto √© do tipo especificado
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos.
 * 
 * O objectref, que deve ser do tipo refer√™ncia, √© exibido na pilha de operandos. O indexbyte1 e indexbyte2 n√£o assinado s√£o usados ‚Äã‚Äãpara construir um √≠ndice no constant pool de tempo de execu√ß√£o da classe atual, em que o valor do √≠ndice √© (indexbyte1 << 8) | indexbyte2. O item de constant pool em tempo de execu√ß√£o no √≠ndice deve ser uma refer√™ncia simb√≥lica a uma classe, matriz ou tipo de interface.
 * Se objectref for nulo, a instru√ß√£o instanceof envia um resultado int de 0 como int na pilha de operandos.
 * Caso contr√°rio, a classe, matriz ou tipo de interface nomeado ser√° resolvido. Se objectref √© uma inst√¢ncia da classe ou matriz resolvida ou implementa a interface resolvida, a instru√ß√£o instanceof envia um resultado int de 1 como int na pilha de operandos; caso contr√°rio, ele envia um resultado int de 0.
 * As regras a seguir s√£o usadas para determinar se um objectref que n√£o √© nulo √© uma inst√¢ncia do tipo resolvido: Se S √© a classe do objeto referido por objectref e T √© o tipo de classe, matriz ou interface resolvido, instanceof determina se objectref √© uma inst√¢ncia de T da seguinte maneira:
 * Se S √© uma classe comum (sem matriz), ent√£o:
 * Se T √© um tipo de classe, ent√£o S deve ser a mesma classe que T ou S deve ser uma subclasse de T;
 * Se T √© um tipo de interface, S deve implementar a interface T.
 * Se S √© um tipo de interface, ent√£o:
 * Se T √© um tipo de classe, T deve ser Objeto.
 * Se T √© um tipo de interface, T deve ser a mesma interface que S ou uma superinterface de S.
 * Se S √© uma classe que representa o tipo de matriz SC [], ou seja, uma matriz de componentes do tipo SC, ent√£o:
 * Se T √© um tipo de classe, T deve ser Objeto.
 * Se T √© um tipo de interface, T deve ser uma das interfaces implementadas por matrizes.
 * Se T for um tipo de matriz TC [], ou seja, uma matriz de componentes do tipo TC, um dos seguintes dever√° ser verdadeiro:
 * TC e SC s√£o do mesmo tipo primitivo.
 * TC e SC s√£o tipos de refer√™ncia e o tipo SC pode ser convertido em TC por essas regras de tempo de execu√ß√£o.
 * 
 */
void manipulador_instanceof (Frame *frame){
    frame->pc += bytecodes[193].bytes + 1;
}

// 194 (0xC2)
/**
 * @brief Entrar o monitor para o objeto
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos.
 * 
 * O objectref deve ser de refer√™ncia do tipo.
 * Cada objeto est√° associado a um monitor. Um monitor est√° bloqueado se e somente se tiver um propriet√°rio. O encadeamento que executa o monitorenter tenta obter a propriedade do monitor associado ao objectref, da seguinte maneira:
 * Se a contagem de entradas do monitor associada ao objectref for zero, o encadeamento entra no monitor e define sua contagem de entradas como uma. O encadeamento √© ent√£o o propriet√°rio do monitor.
 * Se o encadeamento j√° possui o monitor associado ao objectref, ele entra novamente no monitor, aumentando sua contagem de entradas.
 * Se outro encadeamento j√° possuir o monitor associado ao objectref, o encadeamento ser√° bloqueado at√© que a contagem de entradas do monitor seja zero e tente novamente obter a propriedade.
 */
void manipulador_monitorenter (Frame *frame){
    frame->pc += bytecodes[194].bytes + 1;
}

// 195 (0xC3)
/**
 * @brief Sai do monitor para objeto
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos.
 * 
 * O objectref deve ser de refer√™ncia do tipo.
 * O encadeamento que executa monitorexit deve ser o propriet√°rio do monitor associado √† inst√¢ncia referenciada por objectref.
 * O encadeamento diminui a contagem de entradas do monitor associado ao objectref. Se, como resultado, o valor da contagem de entradas for zero, o encadeamento sair√° do monitor e n√£o ser√° mais seu propriet√°rio. Outros threads que est√£o bloqueando a entrada no monitor podem tentar faz√™-lo.
 */
void manipulador_monitorexit (Frame *frame){
    frame->pc += bytecodes[195].bytes + 1;
}

// 196 (0xC4)
/**
 * @brief Extende o √≠ndice de vari√°vel local em alguns bytes
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos.
 * 
 * A instru√ß√£o ampla modifica o comportamento de outra instru√ß√£o. √â necess√°rio um dos dois formatos, dependendo da instru√ß√£o que est√° sendo modificada. A primeira forma da instru√ß√£o ampla modifica uma das instru√ß√µes iload, fload, aload, lload, dload, istore, fstore, astore, lstore, dstore ou ret. A segunda forma se aplica apenas √† instru√ß√£o iinc.
 * Em qualquer um dos casos, o pr√≥prio c√≥digo de opera√ß√£o amplo √© seguido no c√≥digo compilado pelo c√≥digo de opera√ß√£o da instru√ß√£o de modifica√ß√£o ampla. Nos dois formatos, dois bytes n√£o assinados indexbyte1 e indexbyte2 seguem o c√≥digo de opera√ß√£o modificado e s√£o montados em um √≠ndice n√£o assinado de 16 bits em uma vari√°vel local no quadro atual, em que o valor do √≠ndice √© (indexbyte1 << 8) | indexbyte2. O √≠ndice calculado deve ser um √≠ndice na matriz de vari√°veis ‚Äã‚Äãlocais do quadro atual. Onde a instru√ß√£o ampla modifica uma instru√ß√£o lload, dload, lstore ou dstore, o √≠ndice ap√≥s o √≠ndice calculado (√≠ndice + 1) tamb√©m deve ser um √≠ndice na matriz de vari√°veis ‚Äã‚Äãlocais. No segundo formul√°rio, dois bytes imediatos n√£o assinados constbyte1 e constbyte2 seguem indexbyte1 e indexbyte2 no fluxo de c√≥digo. Esses bytes tamb√©m s√£o montados em uma constante de 16 bits assinada, onde a constante √© (constbyte1 << 8) | constbyte2.
 * O bytecode ampliado opera normalmente, exceto pelo uso do √≠ndice mais amplo e, no caso da segunda forma, pela maior faixa de incremento.
 */
void manipulador_wide (Frame *frame){
    u1 opcode = frame->get_prox_byte();
    u1 byte_1 = frame->get_prox_byte();
    u1 byte_2 = frame->get_prox_byte();

    u2 indice = (byte_1 << 8) | byte_2;

    // xload
    {
        if (!bytecodes[opcode].mnemonico.compare("iload"))
            return manipulador_xload2_n(frame, indice, TAG_INT);

        if (!bytecodes[opcode].mnemonico.compare("fload"))
            return manipulador_xload2_n(frame, indice, TAG_FLT);

        if (!bytecodes[opcode].mnemonico.compare("aload"))
            return manipulador_xload2_n(frame, indice, TAG_REF);

        if (!bytecodes[opcode].mnemonico.compare("lload"))
            return manipulador_xload2_n(frame, indice, TAG_LNG);

        if (!bytecodes[opcode].mnemonico.compare("dload"))
            return manipulador_xload2_n(frame, indice, TAG_DBL);
    }

    // xstore
    {
        if (!bytecodes[opcode].mnemonico.compare("istore"))
            return manipulador_xstore2_n(frame, indice, TAG_INT);

        if (!bytecodes[opcode].mnemonico.compare("fstore"))
            return manipulador_xstore2_n(frame, indice, TAG_FLT);

        if (!bytecodes[opcode].mnemonico.compare("astore"))
            return manipulador_xstore2_n(frame, indice, TAG_REF);

        if (!bytecodes[opcode].mnemonico.compare("lstore"))
            return manipulador_xstore2_n(frame, indice, TAG_LNG);

        if (!bytecodes[opcode].mnemonico.compare("dstore"))
            return manipulador_xstore2_n(frame, indice, TAG_DBL);
    }

    u1 valor_1 = frame->get_prox_byte();
    u1 valor_2 = frame->get_prox_byte();
    int16_t valor = (valor_1 << 8) | valor_2;

    manipulador_iincx(frame, indice, valor);
}

// 197 (0xC5)
/**
 * @brief Criar um novi array multidimensional
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos.
 * 
 * O operando de dimens√µes √© um byte sem sinal que deve ser maior ou igual a 1.
 * Representa o n√∫mero de dimens√µes da matriz a ser criada.
 * A pilha de operandos deve conter valores de dimens√µes. 
 * Cada um desses valores representa o n√∫mero de componentes em uma dimens√£o da matriz a ser criada, deve ser do tipo inteiro e n√£o ser negativo. 
 * O count1 √© o comprimento desejado na primeira dimens√£o, o count2 na segunda, etc.
 * Todos os valores de contagem s√£o retirados da pilha de operandos.
 * O indexbyte1 e indexbyte2 sem sinal o s√£o usados ‚Äã‚Äãpara construir um √≠ndice no constant poola de tempo de execu√ß√£o da classe atual, em que o valor do √≠ndice √© (indexbyte1 << 8) | indexbyte2. 
 * O item de constant pool em tempo de execu√ß√£o no √≠ndice deve ser uma refer√™ncia simb√≥lica a uma classe, matriz ou tipo de interface. 
 * A classe, matriz ou tipo de interface nomeado √© resolvido 
 * A entrada resultante deve ser um tipo de dimensionalidade de classe de matriz maior ou igual a dimens√µes.
 * Uma nova matriz multidimensional do tipo de matriz √© alocada a partir do heap coletado pelo lixo. 
 * Se qualquer valor de contagem for zero, nenhuma dimens√£o subsequente ser√° alocada. Os componentes da matriz na primeira dimens√£o s√£o inicializados em sub-matrizes do tipo da segunda dimens√£o e assim por diante.
 * Os componentes da √∫ltima dimens√£o alocada da matriz s√£o inicializados com o valor inicial padr√£o para o tipo de elemento do tipo de matriz.
 * Uma matriz de refer√™nciaref para a nova matriz √© enviada para a pilha de operandos.
 */
void manipulador_multianewarray (Frame *frame){
    frame->pc += bytecodes[197].bytes + 1;
}

// 198 (0xC6)
/**
 * @brief Faz um pulo se a refer√™ncia for nula
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos.
 * 
 * O valor deve ser do tipo refer√™ncia. √â retirado da pilha de operandos. Se o valor for nulo, o branchbyte1 e o branchbyte2 n√£o assinados s√£o usados ‚Äã‚Äãpara construir um deslocamento assinado de 16 bits, onde o deslocamento √© calculado para ser (branchbyte1 << 8) | branchbyte2. A execu√ß√£o prossegue nesse deslocamento a partir do endere√ßo do c√≥digo de opera√ß√£o desta instru√ß√£o nula. O endere√ßo de destino deve ser o de um c√≥digo de opera√ß√£o de uma instru√ß√£o dentro do m√©todo que cont√©m essa instru√ß√£o nula.
 * Caso contr√°rio, a execu√ß√£o continuar√° no endere√ßo da instru√ß√£o ap√≥s esta instru√ß√£o nula.
 */
void manipulador_ifnull (Frame *frame){
    Operando *op = frame->desempilhar();
    int16_t deslocamento = 3;

    if (!op->tipo_int) {
        deslocamento = get_deslocamento(frame);
    }    frame->pc += deslocamento;
}

// 199 (0xC7)
/**
 * @brief Faz um pulo se a refer√™ncia n√£o for nula
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos.
 * 
 * O valor deve ser do tipo refer√™ncia. √â retirado da pilha de operandos. Se o valor n√£o for nulo, o branchbyte1 e o branchbyte2 n√£o assinados ser√£o usados ‚Äã‚Äãpara construir um deslocamento assinado de 16 bits, onde o deslocamento √© calculado como sendo (branchbyte1 << 8) | branchbyte2. A execu√ß√£o prossegue nesse deslocamento a partir do endere√ßo do opcode desta instru√ß√£o ifnonnull. O endere√ßo de destino deve ser o c√≥digo de opera√ß√£o de uma instru√ß√£o dentro do m√©todo que cont√©m esta instru√ß√£o ifnonnull.
 * Caso contr√°rio, a execu√ß√£o continuar√° no endere√ßo da instru√ß√£o ap√≥s esta instru√ß√£o nula.
 */
void manipulador_ifnonnull (Frame *frame){
    Operando *op = frame->desempilhar();
    int16_t deslocamento = 3;

    if (op->tipo_int) {
        deslocamento = get_deslocamento(frame);
    }    frame->pc += deslocamento;
}

// 200 (0xC8)
/**
 * @brief Faz um pulo sempre
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos.
 * 
 * Os bytes sem sinal branchbyte1, branchbyte2, branchbyte3 e branchbyte4 s√£o usados para construir um branchoffset de 32 bits com sinal,
 * em que branchoffset √© (branchbyte1 << 24) | (branchbyte2 << 16) | (branchbyte3 << 8) | branchbyte4
 * O endere√ßo de destino deve ser o de um c√≥digo de opera√ß√£o de uma instru√ß√£o dentro do m√©todo que cont√©m esta instru√ß√£o goto_w
 */
void manipulador_goto_w (Frame *frame){
    u4 byte_1 = frame->attr_codigo->codigo[frame->pc + 1];
    u4 byte_2 = frame->attr_codigo->codigo[frame->pc + 2];
    u4 byte_3 = frame->attr_codigo->codigo[frame->pc + 3];
    u4 byte_4 = frame->attr_codigo->codigo[frame->pc + 4];

    u4 deslocamento = (byte_1 << 24) | (byte_2 << 16) | (byte_3 << 8) | byte_4;
    frame->pc += deslocamento;
}


// 201 (0xC9)
/**
 * @brief Faz um pulo para uma subrotina
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos.
 * 
 * O endere√ßo do c√≥digo de opera√ß√£o da instru√ß√£o imediatamente ap√≥s esta instru√ß√£o jsr_w √© inserido na pilha de operandos como um valor do tipo returnAddress. O branchbyte1 n√£o assinado, branchbyte2, branchbyte3 e branchbyte4 s√£o usados ‚Äã‚Äãpara construir um deslocamento assinado de 32 bits, onde o deslocamento √© (branchbyte1 << 24) | (branchbyte2 << 16) | (branchbyte3 << 8) | branchbyte4. A execu√ß√£o continua nesse deslocamento a partir do endere√ßo desta instru√ß√£o jsr_w. O endere√ßo de destino deve ser o de um c√≥digo de opera√ß√£o de uma instru√ß√£o dentro do m√©todo que cont√©m esta instru√ß√£o jsr_w.
 */
void manipulador_jsr_w (Frame *frame){
    Operando *op = new Operando();
    op->tipo_byte = frame->pc;
    frame->empilhar(op);

    u4 byte_1 = frame->attr_codigo->codigo[frame->pc + 1];
    u4 byte_2 = frame->attr_codigo->codigo[frame->pc + 2];
    u4 byte_3 = frame->attr_codigo->codigo[frame->pc + 3];
    u4 byte_4 = frame->attr_codigo->codigo[frame->pc + 4];

    u4 deslocamento = (byte_1 << 24) | (byte_2 << 16) | (byte_3 << 8) | byte_4;

    frame->pc += deslocamento;
}

// 202 (0xCA)
/**
 * @brief Breakpoint para uso de desenvolvedores
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos.
 * 
 * Utilizado para achar e consertar bugs no c√≥digo. Opcode reservado.
 */
void manipulador_break_point (Frame *frame){
    //RESERVADO DO JAVA
    frame->pc += bytecodes[202].bytes + 1;
}

// 254 (0xFE)
/**
 * @brief Opcode reservado
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos.
 * 
 * Essas instru√ß√µes fornecem "back doors" e "traps" para funcionalidades espec√≠ficas da implementa√ß√£o do software e hardware
 */
void manipulador_impdep_1 (Frame *frame){
    //RESERVADO DO JAVA
    frame->pc += bytecodes[254].bytes + 1;
}

// 255 (0xFF)
/**
 * @brief Opcode reservado
 * 
 * @param frame Recebe o frame que √© relacionado com o m√©todo e cont√©m o array de vari√°veis locais, pilha de operandos, refer√™ncia para tabela de s√≠mbolos.
 * 
 * Essas instru√ß√µes fornecem "back doors" e "traps" para funcionalidades espec√≠ficas da implementa√ß√£o do software e hardware
 */
void manipulador_impdep_2 (Frame *frame){
    //RESERVADO DO JAVA
    frame->pc += bytecodes[255].bytes + 1;
}
